<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import dash
import dash_core_components as dcc
import dash_html_components as html
from datetime import datetime as dt
import dash_table
import dash_daq as daq
from dash.dependencies import Input, Output, State
import copy
from elasticsearch import Elasticsearch
import numpy as np
import json
import plotly.graph_objs as go
from urllib.request import urlopen
import glob

es = Elasticsearch()

try:
    es.index(index=&#39;model&#39;, id=1, body={&#39;name&#39;: &#39;&#39;, &#39;training&#39;: 0, &#39;load&#39;: 0,
                                        &#39;batch&#39;: 0, &#39;epochs&#39;: 0, &#39;samples&#39;: 0,
                                        &#39;completed&#39;: 0})
except:
    print(&#39;Please check the Elasticsearch Server&#39;)

app = dash.Dash(__name__)

layout = dict(
    # autosize=True,
    # automargin=True,
    margin=dict(l=0, r=0, b=6, t=30),
    # hovermode=&#34;closest&#34;,
    plot_bgcolor=&#34;#F9F9F9&#34;,
    paper_bgcolor=&#34;#F9F9F9&#34;,
    # width=350,
    # height=170,
    legend=dict(font=dict(size=10), orientation=&#34;v&#34;),
    mapbox=dict(style=&#34;light&#34;,
                # center=dict(lon=-78.05, lat=42.54),
                zoom=2,
                ),
)

layout_training_confusion = dict(
    autosize=True,
    margin=dict(l=0, r=0, b=6, t=30),
    plot_bgcolor=&#34;#F9F9F9&#34;,
    paper_bgcolor=&#34;#F9F9F9&#34;,

)

layout_training_confusion_met = dict(
    autosize=True,
    margin=dict(l=30, r=0, b=30, t=30),
    plot_bgcolor=&#34;#F9F9F9&#34;,
    paper_bgcolor=&#34;#F9F9F9&#34;,

)

app.layout = html.Div(children=[
    dcc.Interval(
        id=&#39;interval&#39;,
        interval=5 * 1000,  # in milliseconds
        n_intervals=0
    ),
    html.Div(
        [
            html.Div(
                [
                    html.Img(
                        src=app.get_asset_url(&#34;mlbridge-logo.png&#34;),
                        id=&#34;plotly-image&#34;,
                        style={
                            &#34;height&#34;: &#34;70px&#34;,
                            &#34;width&#34;: &#34;auto&#34;,
                            &#34;margin-bottom&#34;: &#34;25px&#34;,
                        },
                    )
                ],
                className=&#34;one-third column&#34;,
            ),
            html.Div(
                [
                    html.Div(
                        [
                            html.H1(
                                &#34;Domain Name Cyber Security&#34;,
                            ),
                        ]
                    )
                ],
                className=&#34;one-half column&#34;,
                id=&#34;title&#34;,
            ),
            html.Div(
                [
                    html.A(
                        html.Button(&#34;Learn More&#34;, id=&#34;learn-more-button&#34;),
                        href=&#34;https://mlbridge.github.io&#34;,
                    )
                ],
                className=&#34;one-third column&#34;,
                id=&#34;button&#34;,
            ),
        ],
        id=&#34;header&#34;,
        className=&#34;row flex-display&#34;,
        style={&#34;margin-bottom&#34;: &#34;25px&#34;},
    ),
    dcc.Tabs(id=&#34;&#34;, value=&#39;historical_analysis&#39;, children=[
        dcc.Tab([
            html.Div(
                [
                    html.Div(
                        [
                            html.Div([
                                html.Div([
                                    html.P(
                                        &#34;Domain Name:&#34;,
                                        style={&#39;display&#39;: &#39;inline&#39;,
                                               &#39;color&#39;: &#39;#2e86c1&#39;,
                                               &#39;font-size&#39;: &#39;18px&#39;},
                                        className=&#34;control_label&#34;
                                    ),
                                    dcc.Input(
                                        placeholder=&#39;Enter a Domain Name&#39;,
                                        type=&#39;text&#39;,
                                        id=&#39;input_text&#39;,
                                        className=&#39;dcc_control&#39;
                                    ),
                                ]),
                                html.Div(id=&#39;input_message&#39;,
                                         className=&#34;control_label&#34;),
                                html.P(&#34;Enter the date range for the analysis:&#34;,
                                       style={&#39;color&#39;: &#39;#2e86c1&#39;,
                                              &#39;font-size&#39;: &#39;18px&#39;, },
                                       className=&#34;control_label&#34;),
                                dcc.DatePickerRange(
                                    id=&#39;date_range&#39;,
                                    min_date_allowed=dt(2020, 1, 5),
                                    className=&#34;dcc_control&#34;,
                                    style={&#39;borderWidth&#39;: &#39;0px&#39;,
                                           &#39;padding&#39;: &#39;0px&#39;,
                                           &#39;float&#39;: &#39;center&#39;,
                                           &#39;margin-left&#39;: &#39;10px&#39;},
                                ),
                                html.Div(id=&#39;date_message&#39;,
                                         className=&#34;control_label&#34;,
                                         style={&#39;margin-bottom&#39;: &#39;10px&#39;}),
                                html.Div([
                                    html.Div([
                                        html.P(&#34;Requests per:&#34;,
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;},
                                               className=&#34;control_label&#34;, ),
                                        dcc.RadioItems(
                                            id=&#34;requests_freq&#34;,
                                            options=[
                                                {&#34;label&#34;: &#34;Day &#34;,
                                                 &#34;value&#34;: &#34;Day&#34;},
                                                {&#34;label&#34;: &#34;Hour &#34;,
                                                 &#34;value&#34;: &#34;Hour&#34;},
                                                {&#34;label&#34;: &#34;Minute &#34;,
                                                 &#34;value&#34;: &#34;Minute&#34;},
                                            ],
                                            labelStyle={&#34;display&#34;:
                                                            &#34;inline-block&#34;},
                                            style={&#39;color&#39;: &#39;#2e86c1&#39;},
                                            className=&#34;dcc_control&#34;,
                                        ),
                                    ]),
                                    html.Div(id=&#39;radio_button_message&#39;,
                                             className=&#34;control_label&#34;,
                                             style={&#39;margin-bottom&#39;: &#39;10px&#39;}),
                                    html.Div([
                                        html.P(
                                            &#34;Hour Range:&#34;,
                                            style={&#39;display&#39;: &#39;inline&#39;,
                                                   &#39;color&#39;: &#39;#2e86c1&#39;,
                                                   &#39;font-size&#39;: &#39;18px&#39;},
                                            className=&#34;control_label&#34;
                                        ),
                                        dcc.Input(
                                            placeholder=&#39;&#39;,
                                            type=&#39;text&#39;,
                                            id=&#39;start_hour&#39;,
                                            className=&#39;dcc_control&#39;,
                                            size=&#39;1&#39;
                                        ),
                                        html.P(
                                            &#34;to&#34;,
                                            style={&#39;display&#39;: &#39;inline&#39;,
                                                   &#39;color&#39;: &#39;#2e86c1&#39;,
                                                   &#39;font-size&#39;: &#39;18px&#39;},
                                            className=&#34;control_label&#34;
                                        ),
                                        dcc.Input(
                                            placeholder=&#39;&#39;,
                                            type=&#39;text&#39;,
                                            id=&#39;end_hour&#39;,
                                            className=&#39;dcc_control&#39;,
                                            size=&#39;1&#39;
                                        ),

                                    ], id=&#39;hour_range&#39;),
                                    html.Div(id=&#39;hour_range_message&#39;,
                                             className=&#34;control_label&#34;,
                                             style={&#39;margin-bottom&#39;: &#39;10px&#39;}),
                                    html.Div([html.P(&#34;Submit the Queries:&#34;,
                                                     style={&#39;display&#39;: &#39;inline&#39;,
                                                            &#39;color&#39;:
                                                                &#39;#2e86c1&#39;,
                                                            &#39;font-size&#39;:
                                                                &#39;18px&#39;},
                                                     className=&#34;control_label&#34;,
                                                     ),
                                              html.Button(&#39;Submit&#39;,
                                                          id=&#39;submit_input&#39;,
                                                          n_clicks=0,
                                                          style={&#39;float&#39;:
                                                                     &#39;center&#39;,
                                                                 &#39;margin-left&#39;:
                                                                     &#39;30px&#39;,
                                                                 &#39;color&#39;:
                                                                     &#39;#2e86c1&#39;},
                                                          ),
                                              ], ),
                                ]),
                            ], className=&#39;pretty_container&#39;),

                            html.Div([
                                dcc.Graph(id=&#39;pie_graph&#39;)
                            ], className=&#34;pretty_container&#34;,
                            )
                        ],
                        className=&#34;four columns&#34;,
                        id=&#34;pie&#34;,
                    ),
                    html.Div([
                        dcc.Tabs(id=&#39;tabs-example&#39;, value=&#39;tab-1&#39;, children=[
                            dcc.Tab([
                                html.Div([dcc.Graph(id=&#39;freq_graph&#39;, )]), ],
                                label=&#39;Requests Plot&#39;, value=&#39;tab-1&#39;,
                                className=&#39;pretty_container&#39;),
                            dcc.Tab([
                                html.Div([
                                    html.Br(),
                                    html.P(
                                        &#34;List of IP addresses that queried the Domain&#34;,
                                        style={&#39;color&#39;: &#39;#333&#39;,
                                               &#39;font-size&#39;: &#39;18px&#39;,
                                               &#39;text-align&#39;: &#39;center&#39;
                                               },
                                        # className=&#34;control_label&#34;
                                    ),
                                    html.Br(),
                                    dash_table.DataTable(
                                        id=&#39;ip_table_&#39;,
                                        columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                  &#39;name&#39;: &#39;Sl. No.&#39;},
                                                 {&#39;id&#39;: &#39;ip&#39;,
                                                  &#39;name&#39;: &#39;IP Address&#39;},
                                                 {&#39;id&#39;: &#39;count&#39;,
                                                  &#39;name&#39;: &#39;Queries&#39;}],
                                        fixed_rows={&#39;headers&#39;: True},
                                        style_table={
                                            &#39;height&#39;: 380,
                                            &#39;overflowY&#39;: &#39;auto&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;margin-left&#39;: &#39;10px&#39;
                                        },
                                        style_as_list_view=True,
                                        style_cell={
                                            &#39;padding&#39;: &#39;5px&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                            &#39;overflow&#39;: &#39;hidden&#39;,
                                            &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                            &#39;textAlign&#39;: &#39;center&#39;,
                                            &#39;font-family&#39;: &#39;Arial&#39;,
                                            &#39;color&#39;: &#39;#333&#39;,
                                            &#39;fontSize&#39;: 15
                                        },
                                        style_header={
                                            &#39;fontWeight&#39;: &#39;bold&#39;
                                        },
                                    )
                                ], )
                            ], label=&#39;IP Address&#39;, value=&#39;tab-2&#39;,
                                className=&#39;pretty_container&#39;, id=&#39;ip_table&#39;),
                            dcc.Tab([
                                daq.ToggleSwitch(
                                    id=&#39;mal_toggle_switch&#39;,
                                    value=False,
                                    vertical=False,
                                    labelPosition=&#39;bottom&#39;,
                                    style={&#39;float&#39;: &#39;right&#39;}
                                ),
                                html.Br(),
                                html.Div([
                                    html.Br(),
                                    html.P(
                                        &#34;Malicious Domains&#34;,
                                        style={&#39;color&#39;: &#39;#333&#39;,
                                               &#39;font-size&#39;: &#39;18px&#39;,
                                               &#39;text-align&#39;: &#39;center&#39;
                                               },
                                        # className=&#34;control_label&#34;
                                    ),
                                    html.Br(),
                                    dash_table.DataTable(
                                        id=&#39;mal_dns_table&#39;,
                                        columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                  &#39;name&#39;: &#39;Sl. No.&#39;},
                                                 {&#39;id&#39;: &#39;domain&#39;,
                                                  &#39;name&#39;: &#39;Domain Names&#39;},
                                                 {&#39;id&#39;: &#39;acc&#39;,
                                                  &#39;name&#39;: &#39;Accuracy %&#39;},
                                                 {&#39;id&#39;: &#39;count&#39;,
                                                  &#39;name&#39;: &#39;Queries&#39;}],
                                        fixed_rows={&#39;headers&#39;: True},
                                        data=[{&#39;sl_no&#39;: 1, &#39;ip&#39;: 1, &#39;count&#39;: 1}],
                                        style_table={
                                            &#39;height&#39;: 360,
                                            &#39;overflowY&#39;: &#39;auto&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;margin-left&#39;: &#39;10px&#39;
                                        },
                                        style_as_list_view=True,
                                        style_cell={
                                            &#39;padding&#39;: &#39;5px&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                            &#39;overflow&#39;: &#39;hidden&#39;,
                                            &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                            &#39;textAlign&#39;: &#39;center&#39;,
                                            &#39;font-family&#39;: &#39;Arial&#39;,
                                            &#39;color&#39;: &#39;#333&#39;,
                                            &#39;fontSize&#39;: 15,
                                            &#39;maxWidth&#39;: 0
                                        },
                                        style_data_conditional=[
                                            {
                                                &#39;if&#39;: {
                                                    &#39;filter_query&#39;: &#39;{acc} &lt; 95&#39;,
                                                    &#39;column_id&#39;: i
                                                },
                                                &#39;backgroundColor&#39;: &#39;#f8b0a8&#39;,
                                            } for i in [&#39;sl_no&#39;, &#39;domain&#39;, &#39;acc&#39;,
                                                        &#39;count&#39;]
                                        ],
                                        style_header={
                                            &#39;fontWeight&#39;: &#39;bold&#39;
                                        },
                                    )
                                ], id=&#39;mal_dns_table_div&#39;),
                                html.Div([
                                    html.Br(),
                                    dcc.Graph(id=&#39;mal_bar_graph&#39;, )],
                                    id=&#39;mal_bar_graph_div&#39;),
                            ],
                                label=&#39;Malicious Domains&#39;,
                                value=&#39;tab-3&#39;, className=&#39;pretty_container&#39;),
                            dcc.Tab([
                                daq.ToggleSwitch(
                                    id=&#39;benign_toggle_switch&#39;,
                                    value=False,
                                    vertical=False,
                                    labelPosition=&#39;bottom&#39;,
                                    style={&#39;float&#39;: &#39;right&#39;}
                                ),
                                html.Br(),
                                html.Div([
                                    html.Br(),
                                    html.P(
                                        &#34;Benign Domains&#34;,
                                        style={&#39;color&#39;: &#39;#333&#39;,
                                               &#39;font-size&#39;: &#39;18px&#39;,
                                               &#39;text-align&#39;: &#39;center&#39;
                                               },
                                        # className=&#34;control_label&#34;
                                    ),
                                    html.Br(),
                                    dash_table.DataTable(
                                        id=&#39;benign_dns_table&#39;,
                                        columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                  &#39;name&#39;: &#39;Sl. No.&#39;},
                                                 {&#39;id&#39;: &#39;domain&#39;,
                                                  &#39;name&#39;: &#39;Domain Names&#39;},
                                                 {&#39;id&#39;: &#39;acc&#39;,
                                                  &#39;name&#39;: &#39;Accuracy %&#39;},
                                                 {&#39;id&#39;: &#39;count&#39;,
                                                  &#39;name&#39;: &#39;Queries&#39;}],
                                        fixed_rows={&#39;headers&#39;: True},
                                        style_table={
                                            &#39;height&#39;: 360,
                                            &#39;overflowY&#39;: &#39;auto&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;margin-left&#39;: &#39;10px&#39;
                                        },
                                        style_as_list_view=True,
                                        style_cell={
                                            &#39;padding&#39;: &#39;5px&#39;,
                                            &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                            &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                            &#39;overflow&#39;: &#39;hidden&#39;,
                                            &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                            &#39;textAlign&#39;: &#39;center&#39;,
                                            &#39;font-family&#39;: &#39;Arial&#39;,
                                            &#39;color&#39;: &#39;#333&#39;,
                                            &#39;fontSize&#39;: 15,
                                            &#39;maxWidth&#39;: 0
                                        },
                                        style_data_conditional=[
                                            {
                                                &#39;if&#39;: {
                                                    &#39;filter_query&#39;: &#39;{acc} &lt; 95&#39;,
                                                    &#39;column_id&#39;: i
                                                },
                                                &#39;backgroundColor&#39;: &#39;#f8b0a8&#39;,
                                            } for i in [&#39;sl_no&#39;, &#39;domain&#39;, &#39;acc&#39;,
                                                        &#39;count&#39;]
                                        ],
                                        style_header={
                                            &#39;fontWeight&#39;: &#39;bold&#39;
                                        },
                                    )
                                ], id=&#39;benign_dns_table_div&#39;),

                                html.Div([
                                    html.Br(),
                                    dcc.Graph(id=&#39;benign_bar_graph&#39;, )],
                                    id=&#39;benign_bar_graph_div&#39;),

                            ],
                                label=&#39;Benign Domains&#39;,
                                value=&#39;tab-4&#39;, className=&#39;pretty_container&#39;),

                            dcc.Tab([
                                html.Div([
                                    html.Div([

                                        html.Br(),

                                        html.P([&#39;Domain Name: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_domain&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;,
                                              &#39;margin-top&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;IP Addresses: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_ips&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;Host Names: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_hostnames&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;City: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_city&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;State: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_state&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;Country: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_country&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;Date Registered: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_date&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                    html.Div([
                                        html.P([&#39;Registrar: &#39;],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;}, ),
                                        html.P([],
                                               style={&#39;display&#39;: &#39;inline&#39;,
                                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                                      &#39;font-size&#39;: &#39;18px&#39;
                                                      },
                                               id=&#39;whois_registrar&#39;)

                                    ], style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                                ], style={&#39;margin-left&#39;: &#39;40px&#39;})

                            ], label=&#39;WhoIS Info&#39;, value=&#39;tab-5&#39;,
                                className=&#39;pretty_container&#39;)

                        ]),

                    ], className=&#34;pretty_container eight columns&#34;,
                        style={&#39;color&#39;: &#39;#2e86c1&#39;, &#39;font-size&#39;: &#39;16px&#39;}),

                ],
                className=&#34;row flex-display&#34;,
            ),
        ], label=&#39;Analysis&#39;, value=&#39;historical_analysis&#39;,
            className=&#39;pretty_container&#39;
        ),

        dcc.Tab([
            html.Div([
                html.Div(
                    [
                        dcc.Tabs(id=&#34;vet_tab_selected&#34;, value=&#39;not_vetted&#39;,
                                 children=[
                                     dcc.Tab([
                                         html.Div([
                                             html.Br(),
                                             html.P(
                                                 &#34;List of Non - Vetted Domains&#34;,
                                                 style={&#39;color&#39;: &#39;#333&#39;,
                                                        &#39;font-size&#39;: &#39;18px&#39;,
                                                        &#39;text-align&#39;: &#39;center&#39;
                                                        },
                                                 # className=&#34;control_label&#34;
                                             ),
                                             html.Br(),
                                             dash_table.DataTable(
                                                 id=&#39;not_vetted_table&#39;,
                                                 columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                           &#39;name&#39;: &#39;Sl. No.&#39;},
                                                          {&#39;id&#39;: &#39;domain&#39;,
                                                           &#39;name&#39;: &#39;Domain Name&#39;},
                                                          {&#39;id&#39;: &#39;class&#39;,
                                                           &#39;name&#39;: &#39;Classification&#39;},
                                                          {&#39;id&#39;: &#39;acc&#39;,
                                                           &#39;name&#39;: &#39;Accuracy %&#39;}],
                                                 fixed_rows={&#39;headers&#39;: True},
                                                 style_table={
                                                     &#39;height&#39;: 380,
                                                     &#39;overflowY&#39;: &#39;auto&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;margin-left&#39;: &#39;10px&#39;
                                                 },
                                                 style_as_list_view=True,
                                                 style_cell={
                                                     &#39;padding&#39;: &#39;5px&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                                     &#39;overflow&#39;: &#39;hidden&#39;,
                                                     &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                                     &#39;textAlign&#39;: &#39;center&#39;,
                                                     &#39;font-family&#39;: &#39;Arial&#39;,
                                                     &#39;color&#39;: &#39;#333&#39;,
                                                     &#39;fontSize&#39;: 15
                                                 },
                                                 style_header={
                                                     &#39;fontWeight&#39;: &#39;bold&#39;
                                                 },
                                                 row_selectable=&#34;multi&#34;,
                                                 selected_rows=[],
                                             )
                                         ], )
                                     ], label=&#39;Not Vetted&#39;, value=&#39;not_vetted&#39;,
                                         className=&#39;pretty_container&#39;),
                                     dcc.Tab([
                                         html.Div([
                                             html.Br(),
                                             html.P(
                                                 &#34;List of Benign Domains&#34;,
                                                 style={&#39;color&#39;: &#39;#333&#39;,
                                                        &#39;font-size&#39;: &#39;18px&#39;,
                                                        &#39;text-align&#39;: &#39;center&#39;
                                                        },
                                                 # className=&#34;control_label&#34;
                                             ),
                                             html.Br(),
                                             dash_table.DataTable(
                                                 id=&#39;benign_vet_table&#39;,
                                                 columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                           &#39;name&#39;: &#39;Sl. No.&#39;},
                                                          {&#39;id&#39;: &#39;domain&#39;,
                                                           &#39;name&#39;: &#39;Domain Name&#39;},
                                                          {&#39;id&#39;: &#39;class&#39;,
                                                           &#39;name&#39;: &#39;Classification&#39;},
                                                          {&#39;id&#39;: &#39;acc&#39;,
                                                           &#39;name&#39;: &#39;Accuracy %&#39;}],
                                                 fixed_rows={&#39;headers&#39;: True},
                                                 style_table={
                                                     &#39;height&#39;: 380,
                                                     &#39;overflowY&#39;: &#39;auto&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;margin-left&#39;: &#39;10px&#39;
                                                 },
                                                 style_as_list_view=True,
                                                 style_cell={
                                                     &#39;padding&#39;: &#39;5px&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                                     &#39;overflow&#39;: &#39;hidden&#39;,
                                                     &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                                     &#39;textAlign&#39;: &#39;center&#39;,
                                                     &#39;font-family&#39;: &#39;Arial&#39;,
                                                     &#39;color&#39;: &#39;#333&#39;,
                                                     &#39;fontSize&#39;: 15
                                                 },
                                                 style_header={
                                                     &#39;fontWeight&#39;: &#39;bold&#39;
                                                 },
                                                 row_selectable=&#34;multi&#34;,
                                                 selected_rows=[],
                                             )
                                         ], )
                                     ], label=&#39;Benign&#39;, value=&#39;benign_vet&#39;,
                                         className=&#39;pretty_container&#39;),
                                     dcc.Tab([
                                         html.Div([
                                             html.Br(),
                                             html.P(
                                                 &#34;List of Honeypotted Domains&#34;,
                                                 style={&#39;color&#39;: &#39;#333&#39;,
                                                        &#39;font-size&#39;: &#39;18px&#39;,
                                                        &#39;text-align&#39;: &#39;center&#39;
                                                        },
                                                 # className=&#34;control_label&#34;
                                             ),
                                             html.Br(),
                                             dash_table.DataTable(
                                                 id=&#39;honeypot_vet_table&#39;,
                                                 columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                           &#39;name&#39;: &#39;Sl. No.&#39;},
                                                          {&#39;id&#39;: &#39;domain&#39;,
                                                           &#39;name&#39;: &#39;Domain Name&#39;},
                                                          {&#39;id&#39;: &#39;class&#39;,
                                                           &#39;name&#39;: &#39;Classification&#39;},
                                                          {&#39;id&#39;: &#39;acc&#39;,
                                                           &#39;name&#39;: &#39;Accuracy %&#39;}],
                                                 fixed_rows={&#39;headers&#39;: True},
                                                 style_table={
                                                     &#39;height&#39;: 380,
                                                     &#39;overflowY&#39;: &#39;auto&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;margin-left&#39;: &#39;10px&#39;
                                                 },
                                                 style_as_list_view=True,
                                                 style_cell={
                                                     &#39;padding&#39;: &#39;5px&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                                     &#39;overflow&#39;: &#39;hidden&#39;,
                                                     &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                                     &#39;textAlign&#39;: &#39;center&#39;,
                                                     &#39;font-family&#39;: &#39;Arial&#39;,
                                                     &#39;color&#39;: &#39;#333&#39;,
                                                     &#39;fontSize&#39;: 15
                                                 },
                                                 style_header={
                                                     &#39;fontWeight&#39;: &#39;bold&#39;
                                                 },
                                                 row_selectable=&#34;multi&#34;,
                                                 selected_rows=[],
                                             )
                                         ], )
                                     ], label=&#39;Honeypot&#39;, value=&#39;honeypot&#39;,
                                         className=&#39;pretty_container&#39;),
                                     dcc.Tab([
                                         html.Div([
                                             html.Br(),
                                             html.P(
                                                 &#34;List of Blacklisted Domains&#34;,
                                                 style={&#39;color&#39;: &#39;#333&#39;,
                                                        &#39;font-size&#39;: &#39;18px&#39;,
                                                        &#39;text-align&#39;: &#39;center&#39;
                                                        },
                                                 # className=&#34;control_label&#34;
                                             ),
                                             html.Br(),
                                             dash_table.DataTable(
                                                 id=&#39;blacklist_vet_table&#39;,
                                                 columns=[{&#39;id&#39;: &#39;sl_no&#39;,
                                                           &#39;name&#39;: &#39;Sl. No.&#39;},
                                                          {&#39;id&#39;: &#39;domain&#39;,
                                                           &#39;name&#39;: &#39;Domain Name&#39;},
                                                          {&#39;id&#39;: &#39;class&#39;,
                                                           &#39;name&#39;: &#39;Classification&#39;},
                                                          {&#39;id&#39;: &#39;acc&#39;,
                                                           &#39;name&#39;: &#39;Accuracy %&#39;}, ],
                                                 fixed_rows={&#39;headers&#39;: True},
                                                 style_table={
                                                     &#39;height&#39;: 380,
                                                     &#39;overflowY&#39;: &#39;auto&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;margin-left&#39;: &#39;10px&#39;
                                                 },
                                                 style_as_list_view=True,
                                                 style_cell={
                                                     &#39;padding&#39;: &#39;5px&#39;,
                                                     &#39;backgroundColor&#39;: &#39;#F9F9F9&#39;,
                                                     &#39;whiteSpace&#39;: &#39;no-wrap&#39;,
                                                     &#39;overflow&#39;: &#39;hidden&#39;,
                                                     &#39;textOverflow&#39;: &#39;ellipsis&#39;,
                                                     &#39;textAlign&#39;: &#39;center&#39;,
                                                     &#39;font-family&#39;: &#39;Arial&#39;,
                                                     &#39;color&#39;: &#39;#333&#39;,
                                                     &#39;fontSize&#39;: 15
                                                 },
                                                 style_header={
                                                     &#39;fontWeight&#39;: &#39;bold&#39;
                                                 },
                                                 row_selectable=&#34;multi&#34;,
                                                 selected_rows=[],
                                             )
                                         ], )
                                     ], label=&#39;Malicious&#39;, value=&#39;blacklist&#39;,
                                         className=&#39;pretty_container&#39;),
                                 ], style={&#39;color&#39;: &#39;#2e86c1&#39;, &#39;font-size&#39;: &#39;18px&#39;}),
                    ], className=&#39;pretty_container nine columns&#39;,
                ),
                html.Div([
                    html.Div([
                        html.P(&#34;Change Status:&#34;,
                               style={&#39;display&#39;: &#39;inline&#39;,
                                      &#39;color&#39;: &#39;#2e86c1&#39;,
                                      &#39;font-size&#39;: &#39;18px&#39;},
                               className=&#34;control_label&#34;, ),
                        dcc.RadioItems(
                            id=&#34;change_status&#34;,
                            options=[
                                {&#34;label&#34;: &#34;Not Vetted&#34;, &#34;value&#34;: &#34;not_vetted&#34;},
                                {&#34;label&#34;: &#34;Benign&#34;, &#34;value&#34;: &#34;benign_vet&#34;},
                                {&#34;label&#34;: &#34;Honeypot&#34;, &#34;value&#34;: &#34;honeypot&#34;},
                                {&#34;label&#34;: &#34;Malicious&#34;, &#34;value&#34;: &#34;blacklist&#34;}
                            ],
                            labelStyle={&#34;display&#34;: &#34;inline-block&#34;},
                            style={&#39;color&#39;: &#39;#2e86c1&#39;},
                            className=&#34;dcc_control&#34;,
                        ),
                        html.Div([html.Div(id=&#39;input_vet_message&#39;,
                                           className=&#34;control_label&#34;),
                                  html.Br(),
                                  html.Button(&#39;Submit&#39;,
                                              id=&#39;submit_vet_input&#39;,
                                              n_clicks=0,
                                              style={&#39;float&#39;: &#39;right&#39;,
                                                     &#39;margin-right&#39;: &#39;-6px&#39;,
                                                     &#39;color&#39;: &#39;#2e86c1&#39;,
                                                     &#39;font&#39;: &#39;Arial&#39;}, ),
                                  ], )
                    ]),

                ], className=&#39;pretty_container three columns&#39;)
            ], className=&#34;row&#34;)

        ], label=&#39;Vetting&#39;, value=&#39;manual_vetting&#39;,
            className=&#39;pretty_container&#39;),

        dcc.Tab([
            html.Div([
                html.Div([
                    html.Div([
                        html.Div([
                            html.P(
                                &#34;Model:&#34;,
                                style={&#39;display&#39;: &#39;inline&#39;,
                                       &#39;color&#39;: &#39;#2e86c1&#39;,
                                       &#39;font-size&#39;: &#39;18px&#39;},
                                className=&#34;control_label&#34;
                            ),
                            dcc.Input(
                                placeholder=&#39;Model Name&#39;,
                                type=&#39;text&#39;,
                                id=&#39;input_model&#39;,
                                className=&#39;dcc_control&#39;,
                                style={&#39;width&#39;: &#39;130px&#39;}
                            ),
                        ]),
                        html.Div(id=&#39;input_model_message&#39;,
                                 className=&#34;control_label&#34;,
                                 style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                        html.Div([
                            html.P(&#34;Model Action:&#34;,
                                   style={&#39;display&#39;: &#39;inline&#39;,
                                          &#39;color&#39;: &#39;#2e86c1&#39;,
                                          &#39;font-size&#39;: &#39;18px&#39;},
                                   className=&#34;control_label&#34;, ),
                            dcc.RadioItems(
                                id=&#34;model_option&#34;,
                                options=[
                                    {&#34;label&#34;: &#34;Train Model &#34;,
                                     &#34;value&#34;: &#34;training&#34;},
                                    {&#34;label&#34;: &#34;Load Model &#34;,
                                     &#34;value&#34;: &#34;load&#34;},
                                ],
                                labelStyle={&#34;display&#34;: &#34;inline-block&#34;},
                                style={&#39;color&#39;: &#39;#2e86c1&#39;},
                                className=&#34;dcc_control&#34;,
                            ),
                        ]),

                        html.Div(id=&#39;model_option_message&#39;,
                                 className=&#34;control_label&#34;,
                                 style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                        html.Div([
                            html.Div([
                                html.P(
                                    &#34;Epochs:&#34;,
                                    style={&#39;display&#39;: &#39;inline&#39;,
                                           &#39;color&#39;: &#39;#2e86c1&#39;,
                                           &#39;font-size&#39;: &#39;18px&#39;},
                                    className=&#34;control_label&#34;
                                ),
                                dcc.Input(
                                    placeholder=&#39;Num of epochs&#39;,
                                    type=&#39;text&#39;,
                                    id=&#39;input_epochs&#39;,
                                    className=&#39;dcc_control&#39;,
                                    style={&#39;width&#39;: &#39;120px&#39;}
                                ),
                            ]),

                            html.Div(id=&#39;epoch_message&#39;,
                                     className=&#34;control_label&#34;,
                                     style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                            html.Div([
                                html.P(
                                    &#34;Batch:&#34;,
                                    style={&#39;display&#39;: &#39;inline&#39;,
                                           &#39;color&#39;: &#39;#2e86c1&#39;,
                                           &#39;font-size&#39;: &#39;18px&#39;},
                                    className=&#34;control_label&#34;
                                ),
                                dcc.Input(
                                    placeholder=&#39;Batch size&#39;,
                                    type=&#39;text&#39;,
                                    id=&#39;input_batch&#39;,
                                    className=&#39;dcc_control&#39;,
                                    style={&#39;width&#39;: &#39;120px&#39;,
                                           &#39;margin-left&#39;: &#39;15px&#39;}
                                ),
                            ]),

                            html.Div(id=&#39;batch_message&#39;,
                                     className=&#34;control_label&#34;,
                                     style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                            html.Div([
                                html.P(
                                    &#34;Sample:&#34;,
                                    style={&#39;display&#39;: &#39;inline&#39;,
                                           &#39;color&#39;: &#39;#2e86c1&#39;,
                                           &#39;font-size&#39;: &#39;18px&#39;},
                                    className=&#34;control_label&#34;
                                ),
                                dcc.Input(
                                    placeholder=&#39;Sample size&#39;,
                                    type=&#39;text&#39;,
                                    id=&#39;input_sample&#39;,
                                    className=&#39;dcc_control&#39;,
                                    style={&#39;width&#39;: &#39;120px&#39;}
                                ),
                            ]),

                            html.Div(id=&#39;sample_message&#39;,
                                     className=&#34;control_label&#34;,
                                     style={&#39;margin-bottom&#39;: &#39;10px&#39;}),

                        ], id=&#39;training_options&#39;),

                        html.Button(&#39;Enter&#39;,
                                    id=&#39;submit_model&#39;,
                                    n_clicks=0,
                                    style={
                                        &#39;margin-left&#39;: &#39;110px&#39;,
                                        &#39;color&#39;: &#39;#2e86c1&#39;,
                                        &#39;font&#39;: &#39;Arial&#39;}, ),

                    ], className=&#39;pretty_container&#39;),
                ], className=&#39;three columns&#39;),

                html.Div([
                    daq.ToggleSwitch(
                        id=&#39;train_switch&#39;,
                        value=False,
                        vertical=False,
                        labelPosition=&#39;bottom&#39;,
                        style={&#39;float&#39;: &#39;right&#39;}
                    ),

                    html.Br(),
                    html.Br(),

                    html.Div([
                        dcc.Graph(id=&#39;loss_graph&#39;, )],
                        id=&#39;loss_graph_div&#39;,
                    ),

                    html.Div([
                        dcc.Graph(id=&#39;acc_graph&#39;, )],
                        id=&#39;acc_graph_div&#39;,
                    )

                ], className=&#39;pretty_container nine columns&#39;),

            ], className=&#39;row&#39;),

            html.Div([

                html.Div([

                    html.P(&#34;Confusion Matrix: Training Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_training&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

                html.Div([

                    html.P(&#34;Confusion Matrix: Validation Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_validation&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

                html.Div([

                    html.P(&#34;Confusion Matrix: Test Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_test&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

            ], className=&#39;row&#39;),

            html.Div([

                html.Div([

                    html.P(&#34;Confusion Metrics: Training Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_met_training&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

                html.Div([

                    html.P(&#34;Confusion Metrics: Validation Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_met_validation&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

                html.Div([

                    html.P(&#34;Confusion Metrics: Test Data&#34;,
                           style={&#39;color&#39;: &#39;#333&#39;,
                                  &#39;font-size&#39;: &#39;18px&#39;,
                                  &#39;hover&#39;: &#39;center&#39;,
                                  &#39;margin-left&#39;: &#39;30px&#39;},
                           className=&#34;control_label&#34;, ),

                    dcc.Graph(id=&#39;confusion_met_test&#39;)

                ],
                    className=&#39;pretty_container custom-training columns&#39;, ),

            ], className=&#39;row&#39;),

        ], label=&#39;Training&#39;, value=&#39;machine_learning&#39;,
            className=&#39;pretty_container&#39;)
    ], style={&#39;color&#39;: &#39;#2e86c1&#39;, &#39;font-size&#39;: &#39;18px&#39;, &#39;width&#39;: &#39;600px&#39;})
])


# Non Decorated Functions

# Historical Analysis

# Control Messages

def input_message(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a message when a domain name is entered.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        value: The domain name that is entered by the user.

    Returns:
        A message as a response to the user as the result of an input for the
        domain name.

    &#34;&#34;&#34;

    try:
        keys = es.indices.get(&#39;*&#39;).keys()
    except:
        keys = []
    if value is None or value == &#39;&#39;:
        return &#39;Please enter a Domain Name&#39;
    elif value in keys:
        return &#39;You have entered: &#39; + value
    else:
        return &#39;Domain Name does not exist in Database&#39;


def date_message(n_clicks, freq, start_date, end_date):
    &#34;&#34;&#34;

    Function that returns a message when the user enters a date range.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        freq: Radio option for selecting the requests per day, hour, minute.
        start_date: Start date for the historical analysis.
        end_date: End date for the historical analysis.

    Returns:
        A message to the user as a response to the inputs for the historical
        analysis.

    &#34;&#34;&#34;

    if start_date is None or end_date is None:
        return &#39;Please enter the date range&#39;
    elif freq == &#39;Hour&#39; or freq == &#39;Minute&#39;:
        start = int(start_date.split(&#39;-&#39;)[2])
        end = int(end_date.split(&#39;-&#39;)[2])
        if (end - start) == 1:
            return &#39;Data from {} to {}&#39;.format(start_date, end_date)
        else:
            return &#39;For hours or minutes please enter two consecutive days&#39;
    elif freq == &#39;Day&#39;:
        start = int(start_date.split(&#39;-&#39;)[1])
        end = int(end_date.split(&#39;-&#39;)[1])
        if (end - start) == 0:
            return &#39;Data from {} to {}&#39;.format(start_date, end_date)
        else:
            return &#39;For days please enter a range within the same month&#39;
    else:
        return &#39;Data from {} to {}&#39;.format(start_date, end_date)


def radio_button_message(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a message when the user selects a radio button.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        value: The radio button option selected by the user.

    Returns:
        A message to the user as a response to the radio button input.

    &#34;&#34;&#34;

    if value is None:
        return &#39;Please select an option&#39;
    else:
        return &#39;You have selected: &#39; + value


def hour_range_message(freq, start, end):
    &#34;&#34;&#34;

    Function that returns a message when the user selects options for historical
    analysis.


    Args:
        freq: Radio option for selecting the requests per day, hour, minute.
        start: Start time for the historical analysis.
        end: End time for the historical analysis.

    Returns:
        A message to the user as a response to the the inputs for obtaining
        the historical analysis.

    &#34;&#34;&#34;

    if freq is None or freq == &#39;Day&#39;:
        return html.Div([])
    elif start is None or start is &#39;&#39; or end is None or end is &#39;&#39;:
        return &#39;Enter an integer hour range (0 to 24)&#39;
    else:
        try:
            start_ = int(start)
            end_ = int(end)
            diff = end_ - start_
            if 0 &lt;= start_ &lt;= 24 and 0 &lt;= end_ &lt;= 24 and diff &gt; 0:
                if freq == &#39;Minute&#39;:
                    if diff &gt; 1:
                        return &#39;The difference between the ranges should be 1&#39;
                    else:
                        return &#39;Hour range from {} to {}&#39;.format(start_, end_)
                else:
                    return &#39;Hour range from {} to {}&#39;.format(start_, end_)
            else:
                return &#39;Please enter relevant integer values (0 to 24) &#39;
        except:
            return &#39;Please enter integer values (0 to 24)&#39;


# Graph and Div Updates


def display_hour_range(value):
    &#34;&#34;&#34;

    Function that either displays the hour range input or hides depending on the
    time radio button selected.

    Args:
        value: Contains the time radio button option selected.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the hour range or hide it.

    &#34;&#34;&#34;

    if value is None or value == &#39;Day&#39;:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}


def update_pie_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a pie graph whether the domain name entered is
    malicious or benign.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the probability whether the domain name entered is
               malicious or benign.

    Returns:
        A pie graph that displays the probability whether the domain name
        entered is malicious or benign.

    &#34;&#34;&#34;

    layout_pie = copy.deepcopy(layout)
    layout_pie[&#34;title&#34;] = &#39;Prediction&#39;
    layout_pie[&#34;font&#34;] = dict(color=&#34;#777777&#34;)
    layout_pie[&#34;legend&#34;] = dict(font=dict(color=&#34;#777777&#34;, size=&#34;10&#34;),
                                orientation=&#34;v&#34;, bgcolor=&#34;rgba(0,0,0,0)&#34;)
    layout_pie[&#34;width&#34;] = &#39;350&#39;
    layout_pie[&#34;height&#34;] = &#39;150&#39;
    if value is None or value is &#39;&#39;:
        data = [
            dict(
                type=&#34;pie&#34;,
                labels=[&#34;Benign&#34;, &#34;Malicious&#34;],
                values=[0.5, 0.5],
                textinfo=&#34;label+percent+name&#34;,
                hole=0.5,
                marker=dict(colors=[&#34;#3498db&#34;, &#34;#f5b041 &#34;]),
                domain={&#34;x&#34;: [0.2, 0.9], &#34;y&#34;: [0.2, 0.9]},
            )]
        figure = dict(data=data, layout=layout_pie)
        return figure
    else:
        try:
            pred = float(es.get(index=value, id=1)[&#39;_source&#39;][&#39;status&#39;])
        except:
            pred = 0.5
        data = [
            dict(
                type=&#34;pie&#34;,
                labels=[&#34;Benign&#34;, &#34;Malicious&#34;],
                values=[1 - pred, pred],
                textinfo=&#34;label+percent+name&#34;,
                hole=0.5,
                marker=dict(colors=[&#34;#3498db&#34;, &#34;#f5b041 &#34;]),
                domain={&#34;x&#34;: [0.2, 0.9], &#34;y&#34;: [0.2, 0.9]},
            )]
        figure = dict(data=data, layout=layout_pie)
        return figure


def update_line_graph(n_clicks, start_hour, end_hour, input_value,
                      start_date, end_date, freq_value):
    &#34;&#34;&#34;

    Function that updates the line graph that displays the frequency, the time
    as well as the date when that particular domain name was queried.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        start_hour: Contains the start the of the hour range between which the
                    frequency of the domain name queried would be investigated.
        end_hour: Contains the end the of the hour range between which frequency
                  of the domain name queried would be investigated.
        input_value: Contains the domain name that has to be investigated.
        start_date: Contains the start the of the date range between which the
                    frequency of the domain name queried would be investigated.
        end_date: Contains the end the of the hour range between which the
                  frequency of the domain name queried would be investigated.
        freq_value: Contains the value of the time radio button selected.

    Returns:
        A line graph.

    &#34;&#34;&#34;

    layout_count = copy.deepcopy(layout)
    layout_count[&#39;title&#39;] = &#34;Requests&#34;
    if freq_value is None:
        freq_value = &#39;&#39;
    layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Time in &#39; + freq_value + &#39;s&#39;}
    layout_count[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_count[&#39;autosize&#39;] = True
    layout_count[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=30),
    if input_value is None or input_value == &#39;&#39; or start_date is None or \
            end_date is None or freq_value is None:
        layout_count[&#39;title&#39;] = &#34;Requests (Please fill the entries)&#34;
        layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
        data = [
            dict(
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[],
                y=[],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            )]
        figure = dict(data=data, layout=layout_count)
        return figure
    else:
        if freq_value == &#39;Minute&#39;:
            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;][start_date][start_hour]
                x = [i for i in req.keys()]
                y = [i for i in req.values()]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure
        elif freq_value == &#39;Hour&#39;:
            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;][start_date]
                hours = [str(i) for i in range(int(start_hour), int(end_hour))]
                x = list(set(hours) &amp; set(req.keys()))
                y = [np.sum(list(req[i].values())) for i in x]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure
        elif freq_value == &#39;Day&#39;:
            start = start_date.split(&#39;-&#39;)
            start[1], start[2] = start[1].lstrip(&#39;0&#39;), start[2].lstrip(&#39;0&#39;)
            end = end_date.split(&#39;-&#39;)
            end[1], end[2] = end[1].lstrip(&#39;0&#39;), end[2].lstrip(&#39;0&#39;)

            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;]
                req = req[start[0]][start[1]]
                print(req)
                if (int(end[1]) - int(start[1])) == 0:
                    days = [str(i) for i in range(int(start[2]),
                                                  (int(end[2]) + 1))]

                    x = list(set(days) &amp; set(req.keys()))
                    y = [req[i] for i in x]
                else:
                    x = [i for i in req.keys()]
                    y = [req[i] for i in x]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure


def update_ip_table(nclicks, value):
    &#34;&#34;&#34;

    Function that updates the IP table in the Elasticsearch Database that
    contains the frequency as well as the IP address of the machine querying
    that particular domain.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the domain name corresponding to which the IP table has
               to be returned.

    Returns:
        The IP address data regarding the number of times a particular domain
        was queried by a particular machine.

    &#34;&#34;&#34;

    if value is None or value == &#39;&#39;:
        return []
    else:
        try:
            count = es.get(index=value, id=1)[&#39;_source&#39;][&#39;count&#39;]
            domain_names = [key for (key, value) in sorted(count.items(),
                                                           key=lambda x: x[1],
                                                           reverse=True)]
            data = [dict({&#39;sl_no&#39;: j + 1, &#39;ip&#39;: i, &#39;count&#39;: count[i]})
                    for i, j in zip(domain_names, range(len(count)))]
        except:
            data = []
        return data


def display_mal_list(value):
    &#34;&#34;&#34;

    Function that either displays the list of malicious domains or hides them
    depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the list of malicious domains or hide them.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}


def display_mal_graph(value):
    &#34;&#34;&#34;

    Function that either displays the graph of the top 20 malicious domains or
    hides them depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the graph of the top 20 malicious domains or hide them.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;unset&#39;}
    else:
        return {&#39;display&#39;: &#39;none&#39;}


def update_mal_dns_table(nclicks, value):
    &#34;&#34;&#34;

    Function that returns the data that contains the list of malicious domains.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the value of the toggle switch.

    Returns:
        Data that contains the list of malicious domains.

    &#34;&#34;&#34;

    try:
        mal = es.get(index=&#39;mal&#39;, id=1)[&#39;_source&#39;]
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;acc&#39;: mal[i][&#39;status&#39;], &#39;count&#39;: mal[i][&#39;count&#39;]})
                for i, j in zip(domain_names, range(len(mal)))]
    except:
        data = []
    return data


def update_mal_bar_graph(value, interval):
    &#34;&#34;&#34;

    Function that returns a bar graph of the top 20 malicious domains.

    Args:
        value: Contains the value of the toggle switch
        interval: Contains the interval after which the figure should be
                  refreshed.

    Returns:
        A bar graph that contains the top 20 malicious domains.

    &#34;&#34;&#34;

    try:
        mal = es.get(index=&#39;mal&#39;, id=1)[&#39;_source&#39;]
    except:
        mal = {}
    if len(mal) &lt; 20:
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
    else:
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)][0:20]

    layout_bar = copy.deepcopy(layout)
    layout_bar[&#39;title&#39;] = &#34;Top Malicious Domains Queried&#34;
    layout_bar[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Rank (Hover over the bars for more info)&#39;,
                           &#39;tickvals&#39;: [(i + 1) for i in
                                        range(len(domain_names))]}
    layout_bar[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_bar[&#39;margin&#39;] = dict(l=30, r=30, b=20, t=30),
    layout_bar[&#39;height&#39;] = &#39;400&#39;
    data = [
        dict(
            type=&#34;bar&#34;,
            hovertext=domain_names,
            x=[(i + 1) for i in range(len(domain_names))],
            y=[int(mal[i][&#39;count&#39;]) for i in domain_names],
        )]
    figure = dict(data=data, layout=layout_bar)
    return figure


def display_benign_list(value):
    &#34;&#34;&#34;

      Function that either displays the list of benign domains or hides them
      depending on the position of the toggle switch.

      Args:
          value: Contains the value of the toggle switch.

      Returns:
          A dictionary that communicates with the Dash interface whether to
          display the list of benign domains or hide them.

      &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}


def display_benign_graph(value):
    &#34;&#34;&#34;

    Function that either displays the graph of the top 20 benign domains or
    hides them depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the graph of the top 20 benign domains or hide them.

    &#34;&#34;&#34;

    if value is True:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}


def update_benign_dns_table(nclicks, value):
    &#34;&#34;&#34;

    Function that returns the data that contains the list of benign domains.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the value of the toggle switch.

    Returns:
        Data that contains the list of benign domains.

    &#34;&#34;&#34;

    try:
        benign = es.get(index=&#39;benign&#39;, id=1)[&#39;_source&#39;]
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;acc&#39;: benign[i][&#39;status&#39;], &#39;count&#39;: benign[i][&#39;count&#39;]})
                for i, j in zip(domain_names, range(len(benign)))]
    except:
        data = []
    return data


def update_benign_bar_graph(value, interval):
    &#34;&#34;&#34;

    Function that returns a bar graph of the top 20 benign domains.

    Args:
        value: Contains the value of the toggle switch
        interval: Contains the interval after which the figure should be
                  refreshed.

    Returns:
        A bar graph that contains the top benign domains.

    &#34;&#34;&#34;
    
    try:
        benign = es.get(index=&#39;benign&#39;, id=1)[&#39;_source&#39;]
    except:
        benign = {}
    if len(benign) &lt; 20:
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
    else:
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)][0:20]

    layout_bar = copy.deepcopy(layout)
    layout_bar[&#39;title&#39;] = &#34;Top Benign Domains Queried&#34;
    layout_bar[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Rank (Hover over the bars for more info)&#39;,
                           &#39;tickvals&#39;: [(i + 1) for i in
                                        range(len(domain_names))]}
    layout_bar[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_bar[&#39;margin&#39;] = dict(l=30, r=30, b=20, t=30),
    layout_bar[&#39;height&#39;] = &#39;400&#39;
    data = [
        dict(
            type=&#34;bar&#34;,
            hovertext=domain_names,
            x=[(i + 1) for i in range(len(domain_names))],
            y=[int(benign[i][&#39;count&#39;]) for i in domain_names],
        )]
    figure = dict(data=data, layout=layout_bar)
    return figure


def update_whois_info(n_clicks, domain_name):
    &#34;&#34;&#34;

    Function that returns the the information of the domain name queried from
    the WhoIS Database.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        domain_name: Contains the domain name queried.

    Returns:
        Information from the WhoIS Database regarding the domain name queried.

    &#34;&#34;&#34;

    whois_ip = &#39;&#39;
    whois_hostnames = &#39;&#39;
    whois_city = &#39;&#39;
    whois_state = &#39;&#39;
    whois_country = &#39;&#39;
    whois_date_registered = &#39;&#39;
    whois_registrar = &#39;&#39;

    if domain_name is None or domain_name == &#39;&#39;:
        domain_name = &#39;&#39;

    else:

        try:
            api_key = &#39;at_r4GfBsGDWwZpuaga703KB9HZBmG6S&#39;
            url = &#39;https://www.whoisxmlapi.com/whoisserver/WhoisService?&#39; \
                  + &#39;domainName=&#39; + domain_name + &#39;&amp;apiKey=&#39; + api_key + \
                  &#34;&amp;outputFormat=JSON&#34; + &#34;&amp;ip=1&#34;

            data = json.loads(urlopen(url).read().decode(&#39;utf8&#39;))

            if &#39;ErrorMessage&#39; in data.keys():

                domain_name = data[&#39;msg&#39;]

            else:

                try:
                    ips = data[&#39;WhoisRecord&#39;][&#39;ips&#39;]
                    for i in ips:
                        whois_ip = whois_ip + i + &#39; | &#39;
                except:
                    whois_ip = &#39;-&#39;

                try:
                    hostnames = data[&#39;WhoisRecord&#39;][&#39;nameServers&#39;][&#39;hostNames&#39;]
                    for i in hostnames:
                        whois_hostnames = whois_hostnames + i + &#39; | &#39;
                except:
                    whois_hostnames = &#39;-&#39;

                try:
                    whois_city = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;city&#39;]
                except:
                    whois_city = &#39;-&#39;

                try:
                    whois_state = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;state&#39;]
                except:
                    whois_state = &#39;-&#39;

                try:
                    whois_country = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;country&#39;]
                except:
                    whois_country = &#39;-&#39;

                try:
                    whois_date_registered = \
                        data[&#39;WhoisRecord&#39;][&#39;registryData&#39;][&#39;createdDateNormalized&#39;]
                except:
                    whois_date_registered = &#39;-&#39;

                try:
                    whois_registrar = data[&#39;WhoisRecord&#39;][&#39;registrarName&#39;]
                except:
                    whois_registrar = &#39;-&#39;

        except:
            domain_name = domain_name + &#39; (WhoIS Unresponsive)&#39;

    return domain_name, whois_ip, whois_hostnames, whois_city, \
           whois_state, whois_country, whois_date_registered, whois_registrar


# Manual Vetting


def update_and_input_vet_message_vet_tables(n_clicks, not_vetted_select,
                                            benign_vet_select,
                                            honeypot_vet_select,
                                            blacklist_vet_select,
                                            change_status):
    &#34;&#34;&#34;

    Function that returns a message regarding the options selected for manually
    vetting domain names.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        not_vetted_select: Contains the list of domains that have been selected
                           for vetting from the list of non - vetted domains.
        benign_vet_select: Contains the list of domains that have been selected
                           for a list change from the list of benign domains.
        honeypot_vet_select: Contains the list of domains that have been selected
                             for a list change from the list of honeypot domains.
        blacklist_vet_select: Contains the list of domains that have been selected
                              for a list change from the list of malicious domains.
        change_status: Radio button that contains option of the list the domains
                       selected have to be changed to.

    Returns:
        A message regarding the options selected for manually vetting domain
        names.

    &#34;&#34;&#34;

    vet_list = [not_vetted_select, benign_vet_select, honeypot_vet_select,
                blacklist_vet_select]
    es_vet_list_names = [&#39;not_vetted&#39;, &#39;benign_vet&#39;, &#39;honeypot&#39;, &#39;blacklist&#39;]
    if change_status is None:
        for i in vet_list:
            if i is not None and i != []:
                return &#39;Please select the option, the entries have to be &#39; \
                       &#39;changed to.&#39;, None, None, None, None, None
        return &#39;Please select the entries on the left whose status has to be &#39; \
               &#39;changed and also select the option, the entries have to be &#39; \
               &#39;changed to.&#39;, None, None, None, None, None
    else:
        for i, j in zip(vet_list, es_vet_list_names):
            if i is not None and i != []:
                if change_status in j:
                    return &#39;Please enter a different option to change the &#39; \
                           &#39;status.&#39;, None, None, None, None, None
                else:
                    body_to_change = es.get(index=j, id=1)[&#39;_source&#39;]
                    body_to_change_keys = \
                        list(es.get(index=j, id=1)[&#39;_source&#39;].keys())

                    for k in i:
                        body_to_update = \
                            {&#39;doc&#39;:
                                 {body_to_change_keys[k]:
                                      body_to_change[body_to_change_keys[k]]}}
                        es.update(index=change_status, id=1, body=body_to_update)

                    for k in i:
                        del (body_to_change[body_to_change_keys[k]])
                    es.index(j, id=1, body=body_to_change)
                    return &#39;Status change successful.&#39;, \
                           None, None, None, None, None

        return &#39;Please select the entries on the left whose status has to be &#39; \
               &#39;changed.&#39;, None, None, None, None, None


def update_not_vetted_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of non - vetted domains
    after a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of non - vetted domains.

    &#34;&#34;&#34;

    try:
        not_vetted = es.get(index=&#39;not_vetted&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: not_vetted[i][&#39;class&#39;],
                      &#39;acc&#39;: not_vetted[i][&#39;acc&#39;]})
                for i, j in zip(not_vetted.keys(), range(len(not_vetted)))]
    except:
        data = []
    return data


def update_benign_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of benign domains after a
    specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of benign domains.

    &#34;&#34;&#34;

    try:
        benign_vet = es.get(index=&#39;benign_vet&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: benign_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: benign_vet[i][&#39;acc&#39;]})
                for i, j in zip(benign_vet.keys(), range(len(benign_vet)))]
    except:
        data = []
    return data


def update_honeypot_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of honeypot domains after
    a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of honeypot domains.

    &#34;&#34;&#34;

    try:
        honeypot_vet = es.get(index=&#39;honeypot&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: honeypot_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: honeypot_vet[i][&#39;acc&#39;]})
                for i, j in zip(honeypot_vet.keys(), range(len(honeypot_vet)))]
    except:
        data = []
    return data


def update_blacklist_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of malicious domains
    after a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of malicious domains.

    &#34;&#34;&#34;

    try:
        blacklist_vet = es.get(index=&#39;blacklist&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: blacklist_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: blacklist_vet[i][&#39;acc&#39;]})
                for i, j in zip(blacklist_vet.keys(),
                                range(len(blacklist_vet)))]
    except:
        data = []
    return data


# Training

def update_es_parameters_and_messages(model_name, option, epochs_input,
                                      batch_input, sample_input):
    &#34;&#34;&#34;

    Functions that updates model training information in the Elasticsearch
    Database and also returns messages for the data entered by the user.

    Args:
        model_name: Contains the model name entered by the user.
        option: Contains the option whether to train a new model or display the
                statistics that explain the efficacy of an older model.
        epochs_input: Contains the number of epochs entered for training by the
                      user.
        batch_input: Contains the batch size entered for training by the user.
        sample_input: Contains the sample size entered for training by the user.

    Returns:
        Messages to the user as a response to the options filled.

    &#34;&#34;&#34;

    model_message = &#39;Please enter a model name&#39;
    epochs_message = &#39;Please enter an integer value&#39;
    batch_message = &#39;Please enter an integer value&#39;
    sample_message = &#39;Please enter an integer value&#39;
    model_check, option_check = False, False
    epochs_check, batch_check, sample_check = False, False, False

    if (model_name is not None) and (model_name != &#39;&#39;):
        model_check = True
    if option is not None:
        option_check = True

    if (not model_check) and (not option_check):
        model_message = &#39;Enter model name and option&#39;
    elif model_check and (not option_check):
        model_message = &#39;Please enter an option&#39;
    elif (not model_check) and option_check:
        model_message = &#39;Please enter a model name&#39;
    else:
        if option == &#39;load&#39;:
            models = \
                glob.glob(&#39;../../../mlbridge-machine-learning/saved_models/*.hdf5&#39;)
            for i in models:
                name = i.replace(&#39;\\&#39;, &#39;/&#39;)
                name = name.split(&#39;/&#39;)
                name.reverse()
                if model_name == name[0].split(&#39;.&#39;)[0]:
                    update_body = {&#39;doc&#39;: {&#39;name&#39;: model_name,
                                           &#39;training&#39;: 0, &#39;load&#39;: 1, &#39;batch&#39;: 0,
                                           &#39;epochs&#39;: 0, &#39;samples&#39;: 0}}
                    try:
                        es.update(index=&#39;model&#39;, id=1, body=update_body)
                        model_message = &#39;Model Loaded&#39;
                    except:
                        model_message = &#39;Model Loaded&#39;
                else:
                    model_message = &#39;Model does not exist&#39;

        elif option == &#39;training&#39;:

            if (epochs_input is None) or (epochs_input == &#39;&#39;):
                epochs_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    epochs = int(epochs_input)
                    if epochs &gt; 0:
                        epochs_check = True
                        epochs_message = &#39;You have entered &#39; + str(epochs) + &#39; epochs&#39;
                    else:
                        epochs_message = &#39;Please enter a value greater than 0&#39;
                except:
                    epochs_message = &#39;Please enter an integer value&#39;

            if (batch_input is None) or (batch_input == &#39;&#39;):
                batch_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    batch = int(batch_input)
                    if batch &gt; 0:
                        batch_check = True
                        batch_message = &#39;Entered batch-size &#39; + str(batch)
                    else:
                        batch_message = &#39;Please enter a value greater than 0&#39;
                except:
                    batch_message = &#39;Please enter an integer value&#39;

            if (sample_input is None) and (sample_input == &#39;&#39;):
                sample_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    samples = int(sample_input)
                    if samples &gt; 0:
                        sample_check = True
                        sample_message = &#39;Entered &#39; + str(sample_input) + &#39; samples&#39;
                    else:
                        sample_message = &#39;Please enter a value greater than 0&#39;
                except:
                    sample_message = &#39;Please enter an integer value&#39;

            if epochs_check and batch_check and sample_check:
                try:
                    update_body = {&#39;doc&#39;: {&#39;name&#39;: model_name,
                                           &#39;training&#39;: 1, &#39;load&#39;: 0,
                                           &#39;batch&#39;: batch, &#39;epochs&#39;: epochs,
                                           &#39;samples&#39;: samples}}
                    es.update(index=&#39;model&#39;, id=1, body=update_body)
                    model_message = &#39;Training the model&#39;
                except:
                    model_message = &#39;Issue with Elasticsearch&#39;

    return model_message, epochs_message, batch_message, sample_message


def update_display_training_options(value):
    &#34;&#34;&#34;

    Function that either displays the input fields required to be filled in by
    the user for training or hides them.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the input fields required to be filled in by the user for
        training or hide them.

    &#34;&#34;&#34;

    if value is None or value == &#39;load&#39;:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}


def update_loss_accuracy_display(value):
    &#34;&#34;&#34;

    Function that either displays the loss graph or the accuracy graph of the
    deep learning model depending on the value of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        Two dictionaries that communicates with the Dash interface whether to
        display the accuracy graph or loss graph.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;unset&#39;}, {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;none&#39;}, {&#39;display&#39;: &#39;unset&#39;}


def update_loss_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a line graph of the loss graph (loss percentage vs
    epochs) of the deep learning model.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the model name that is currently being trained or is
               an older model whose efficacy has to be investigated.

    Returns:
        A loss graph of the deep learning model.

    &#34;&#34;&#34;

    layout_loss = copy.deepcopy(layout)
    layout_loss[&#39;title&#39;] = &#39;Loss Graph&#39;
    layout_loss[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Epochs&#39;}
    layout_loss[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Loss %&#39;}
    layout_loss[&#39;autosize&#39;] = False
    layout_loss[&#39;height&#39;] = &#39;400&#39;
    layout_loss[&#39;width&#39;] = &#39;850&#39;
    layout_loss[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=0),
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 1) or \
            (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1):
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)

    return figure


def update_acc_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a line graph of the accuracy graph (accuracy
    percentage vs epochs) of the deep learning model.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the model name that is currently being trained or is
               an older model whose efficacy has to be investigated.

    Returns:
        An accuracy graph of the deep learning model.

    &#34;&#34;&#34;

    layout_loss = copy.deepcopy(layout)
    layout_loss[&#39;title&#39;] = &#39;Accuracy Graph&#39;
    layout_loss[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Epochs&#39;}
    layout_loss[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Accuracy %&#39;}
    layout_loss[&#39;autosize&#39;] = False
    layout_loss[&#39;height&#39;] = &#39;400&#39;
    layout_loss[&#39;width&#39;] = &#39;850&#39;
    layout_loss[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=0),
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 1) or \
            (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1):
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    return figure


def update_confusion_matrix_training(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the training
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the training dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_train&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_train&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)

    return figure


def update_confusion_matrix_validation(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the validation
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the validation dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_valid&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_valid&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    return figure


def update_confusion_matrix_test(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the test dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the test dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_test&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_test&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    return figure


def update_confusion_metrics_training(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the training
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the training dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_train&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_train&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_train&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_train&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_train&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_train&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_train&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_train&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    return figure


def update_confusion_metrics_validation(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the validation
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the validation dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_valid&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_valid&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_valid&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_valid&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_valid&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_valid&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_valid&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_valid&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    return figure


def update_confusion_metrics_test(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the test
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the test dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_test&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_test&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_test&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_test&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39; \
                                                &#39;&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_test&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_test&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_test&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_test&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)
    return figure


# Dash Functions

# Historical Analysis

# Control Messages


@app.callback(Output(&#39;input_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def input_message_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the input_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    return_input_message = input_message(n_clicks, value)
    return return_input_message


@app.callback(Output(&#39;date_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;requests_freq&#39;, &#39;value&#39;),
               Input(&#39;date_range&#39;, &#39;start_date&#39;),
               Input(&#39;date_range&#39;, &#39;end_date&#39;)])
def date_message_dash(n_clicks, freq, start_date, end_date):
    &#34;&#34;&#34;

    Function that just calls the date_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    date_message_ = date_message(n_clicks, freq, start_date, end_date)
    return date_message_


@app.callback(Output(&#39;radio_button_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;requests_freq&#39;, &#39;value&#39;)])
def radio_button_message_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the radio_button_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    radio_button_message_ = radio_button_message(n_clicks, value)
    return radio_button_message_


@app.callback(Output(&#39;hour_range_message&#39;, &#39;children&#39;),
              [Input(&#39;requests_freq&#39;, &#39;value&#39;),
               Input(&#39;start_hour&#39;, &#39;value&#39;),
               Input(&#39;end_hour&#39;, &#39;value&#39;)])
def hour_range_message_dash(freq, start, end):
    &#34;&#34;&#34;

    Function that just calls the hour_range_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    hour_range_message_ = hour_range_message(freq, start, end)
    return hour_range_message_


# Graphs and Div Updates


@app.callback(Output(&#39;hour_range&#39;, &#39;style&#39;),
              [Input(&#39;requests_freq&#39;, &#39;value&#39;)])
def display_hour_range_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_hour_range function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_hour_range(value)
    return display


@app.callback(Output(&#39;pie_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_pie_graph_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_pie_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_pie_graph(n_clicks, value)
    return figure


@app.callback(Output(&#39;freq_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;), ],
              [State(&#39;start_hour&#39;, &#39;value&#39;),
               State(&#39;end_hour&#39;, &#39;value&#39;),
               State(&#39;input_text&#39;, &#39;value&#39;),
               State(&#39;date_range&#39;, &#39;start_date&#39;),
               State(&#39;date_range&#39;, &#39;end_date&#39;),
               State(&#39;requests_freq&#39;, &#39;value&#39;)])
def update_line_graph_dash(n_clicks, start_hour, end_hour, input_value,
                           start_date, end_date, freq_value):
    &#34;&#34;&#34;

    Function that just calls the update_line_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_line_graph(n_clicks, start_hour, end_hour, input_value,
                               start_date, end_date, freq_value)
    return figure


@app.callback(Output(&#39;ip_table_&#39;, &#39;data&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_ip_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_ip_table function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_ip_table(nclicks, value)
    return data


@app.callback(Output(&#39;mal_dns_table_div&#39;, &#39;style&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;)])
def display_mal_list_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_mal_list function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_mal_list(value)
    return display


@app.callback(Output(&#39;mal_bar_graph_div&#39;, &#39;style&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;)])
def display_mal_graph_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_mal_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_mal_graph(value)
    return display


@app.callback(Output(&#39;mal_dns_table&#39;, &#39;data&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_mal_dns_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_mal_dns_table function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_mal_dns_table(nclicks, value)
    return data


@app.callback(Output(&#39;mal_bar_graph&#39;, &#39;figure&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_mal_bar_graph_dash(value, interval):
    &#34;&#34;&#34;

    Function that just calls the update_mal_bar_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_mal_bar_graph(value, interval)
    return figure


@app.callback(Output(&#39;benign_dns_table_div&#39;, &#39;style&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;)])
def display_benign_list_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_benign_list function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_benign_list(value)
    return display


@app.callback(Output(&#39;benign_bar_graph_div&#39;, &#39;style&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;)])
def display_benign_graph_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_benign_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_benign_graph(value)
    return display


@app.callback(Output(&#39;benign_dns_table&#39;, &#39;data&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_dns_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_benign_dns_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_benign_dns_table(nclicks, value)
    return data


@app.callback(Output(&#39;benign_bar_graph&#39;, &#39;figure&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_bar_graph_dash(value, interval):
    &#34;&#34;&#34;

    Function that just calls the update_benign_bar_graph function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_benign_bar_graph(value, interval)
    return figure


@app.callback([Output(&#39;whois_domain&#39;, &#39;children&#39;),
               Output(&#39;whois_ips&#39;, &#39;children&#39;),
               Output(&#39;whois_hostnames&#39;, &#39;children&#39;),
               Output(&#39;whois_city&#39;, &#39;children&#39;),
               Output(&#39;whois_state&#39;, &#39;children&#39;),
               Output(&#39;whois_country&#39;, &#39;children&#39;),
               Output(&#39;whois_date&#39;, &#39;children&#39;),
               Output(&#39;whois_registrar&#39;, &#39;children&#39;)],
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_whois_info_dash(n_clicks, domain_name):
    &#34;&#34;&#34;

    Function that just calls the update_whois_info function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    whois_domain, whois_ips, whois_hostnames, whois_city, whois_state, \
    whois_country, whois_date, whois_registrar = \
        update_whois_info(n_clicks, domain_name)

    return whois_domain, whois_ips, whois_hostnames, whois_city, whois_state, \
           whois_country, whois_date, whois_registrar


# Manual Vetting

@app.callback([Output(&#39;input_vet_message&#39;, &#39;children&#39;),
               Output(&#39;change_status&#39;, &#39;value&#39;),
               Output(&#39;not_vetted_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;benign_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;honeypot_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;blacklist_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;)],
              [Input(&#39;submit_vet_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;not_vetted_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;benign_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;honeypot_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;blacklist_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;change_status&#39;, &#39;value&#39;), ])
def update_and_input_vet_message_vet_tables_dash(n_clicks, not_vetted_select,
                                                 benign_vet_select,
                                                 honeypot_vet_select,
                                                 blacklist_vet_select,
                                                 change_status):
    &#34;&#34;&#34;

    Function that just calls the update_and_input_vet_message_vet_tables
    function. This function is decorated by the Dash Application decorator. Such
    an arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    message, _, _, _, _, _ = update_and_input_vet_message_vet_tables(n_clicks,
                                                                     not_vetted_select,
                                                                     benign_vet_select,
                                                                     honeypot_vet_select,
                                                                     blacklist_vet_select,
                                                                     change_status)
    return message, None, None, None, None, None


@app.callback(Output(&#39;not_vetted_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_not_vetted_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_not_vetted_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_not_vetted_table(n_intervals)
    return data


@app.callback(Output(&#39;benign_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_benign_vet_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_benign_vet_table(n_intervals)
    return data


@app.callback(Output(&#39;honeypot_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_honeypot_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_honeypot_vet_table function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_honeypot_vet_table(n_intervals)
    return data


@app.callback(Output(&#39;blacklist_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_blacklist_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_blacklist_vet_table function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_blacklist_vet_table(n_intervals)
    return data


# Training

@app.callback([Output(&#39;input_model_message&#39;, &#39;children&#39;),
               Output(&#39;epoch_message&#39;, &#39;children&#39;),
               Output(&#39;batch_message&#39;, &#39;children&#39;),
               Output(&#39;sample_message&#39;, &#39;children&#39;)],
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;)],
              [State(&#39;model_option&#39;, &#39;value&#39;),
               State(&#39;input_model&#39;, &#39;value&#39;),
               State(&#39;input_epochs&#39;, &#39;value&#39;),
               State(&#39;input_batch&#39;, &#39;value&#39;),
               State(&#39;input_sample&#39;, &#39;value&#39;)])
def update_es_parameters_and_messages_dash(n_clicks, option, model, epochs,
                                           batch, samples):
    &#34;&#34;&#34;

    Function that just calls the update_es_parameters_and_messages function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    model_message, epochs_message, batch_message, samples_message \
        = update_es_parameters_and_messages(model, option, epochs, batch, samples)
    return model_message, epochs_message, batch_message, samples_message


@app.callback(Output(&#39;training_options&#39;, &#39;style&#39;),
              [Input(&#39;model_option&#39;, &#39;value&#39;)])
def update_display_training_options_dash(value):
    &#34;&#34;&#34;

    Function that just calls the update_display_training_options function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = update_display_training_options(value)
    return display


@app.callback([Output(&#39;loss_graph&#39;, &#39;style&#39;),
               Output(&#39;acc_graph&#39;, &#39;style&#39;)],
              [Input(&#39;train_switch&#39;, &#39;value&#39;)])
def update_loss_accuracy_display_dash(value):
    &#34;&#34;&#34;

    Function that just calls the update_loss_accuracy_display function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display_loss, display_acc = update_loss_accuracy_display(value)
    return display_loss, display_acc


@app.callback(Output(&#39;loss_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_loss_graph_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_loss_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_loss_graph(n_clicks, value)
    return figure


@app.callback(Output(&#39;acc_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_acc_graph_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_acc_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_acc_graph(n_clicks, value)
    return figure


@app.callback(Output(&#39;confusion_training&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_training_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_training function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_training(value)
    return figure


@app.callback(Output(&#39;confusion_validation&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_validation_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_validation function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_validation(value)
    return figure


@app.callback(Output(&#39;confusion_test&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_test_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_test function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_test(value)
    return figure


@app.callback(Output(&#39;confusion_met_training&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_training_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_training function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_training(value)
    return figure


@app.callback(Output(&#39;confusion_met_validation&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_validation_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_validation function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_validation(value)
    return figure


@app.callback(Output(&#39;confusion_met_test&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_test_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_test function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_test(value)
    return figure


if __name__ == &#39;__main__&#39;:
    app.run_server(debug=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ui.date_message"><code class="name flex">
<span>def <span class="ident">date_message</span></span>(<span>n_clicks, freq, start_date, end_date)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a message when the user enters a date range.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Number of clicks registered by the submit button.</dd>
<dt><strong><code>freq</code></strong></dt>
<dd>Radio option for selecting the requests per day, hour, minute.</dd>
<dt><strong><code>start_date</code></strong></dt>
<dd>Start date for the historical analysis.</dd>
<dt><strong><code>end_date</code></strong></dt>
<dd>End date for the historical analysis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A message to the user as a response to the inputs for the historical
analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_message(n_clicks, freq, start_date, end_date):
    &#34;&#34;&#34;

    Function that returns a message when the user enters a date range.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        freq: Radio option for selecting the requests per day, hour, minute.
        start_date: Start date for the historical analysis.
        end_date: End date for the historical analysis.

    Returns:
        A message to the user as a response to the inputs for the historical
        analysis.

    &#34;&#34;&#34;

    if start_date is None or end_date is None:
        return &#39;Please enter the date range&#39;
    elif freq == &#39;Hour&#39; or freq == &#39;Minute&#39;:
        start = int(start_date.split(&#39;-&#39;)[2])
        end = int(end_date.split(&#39;-&#39;)[2])
        if (end - start) == 1:
            return &#39;Data from {} to {}&#39;.format(start_date, end_date)
        else:
            return &#39;For hours or minutes please enter two consecutive days&#39;
    elif freq == &#39;Day&#39;:
        start = int(start_date.split(&#39;-&#39;)[1])
        end = int(end_date.split(&#39;-&#39;)[1])
        if (end - start) == 0:
            return &#39;Data from {} to {}&#39;.format(start_date, end_date)
        else:
            return &#39;For days please enter a range within the same month&#39;
    else:
        return &#39;Data from {} to {}&#39;.format(start_date, end_date)</code></pre>
</details>
</dd>
<dt id="ui.date_message_dash"><code class="name flex">
<span>def <span class="ident">date_message_dash</span></span>(<span>n_clicks, freq, start_date, end_date)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the date_message function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;date_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;requests_freq&#39;, &#39;value&#39;),
               Input(&#39;date_range&#39;, &#39;start_date&#39;),
               Input(&#39;date_range&#39;, &#39;end_date&#39;)])
def date_message_dash(n_clicks, freq, start_date, end_date):
    &#34;&#34;&#34;

    Function that just calls the date_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    date_message_ = date_message(n_clicks, freq, start_date, end_date)
    return date_message_</code></pre>
</details>
</dd>
<dt id="ui.display_benign_graph"><code class="name flex">
<span>def <span class="ident">display_benign_graph</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the graph of the top 20 benign domains or
hides them depending on the position of the toggle switch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the graph of the top 20 benign domains or hide them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_benign_graph(value):
    &#34;&#34;&#34;

    Function that either displays the graph of the top 20 benign domains or
    hides them depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the graph of the top 20 benign domains or hide them.

    &#34;&#34;&#34;

    if value is True:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.display_benign_graph_dash"><code class="name flex">
<span>def <span class="ident">display_benign_graph_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the display_benign_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;benign_bar_graph_div&#39;, &#39;style&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;)])
def display_benign_graph_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_benign_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_benign_graph(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.display_benign_list"><code class="name flex">
<span>def <span class="ident">display_benign_list</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the list of benign domains or hides them
depending on the position of the toggle switch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the list of benign domains or hide them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_benign_list(value):
    &#34;&#34;&#34;

      Function that either displays the list of benign domains or hides them
      depending on the position of the toggle switch.

      Args:
          value: Contains the value of the toggle switch.

      Returns:
          A dictionary that communicates with the Dash interface whether to
          display the list of benign domains or hide them.

      &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.display_benign_list_dash"><code class="name flex">
<span>def <span class="ident">display_benign_list_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the display_benign_list function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;benign_dns_table_div&#39;, &#39;style&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;)])
def display_benign_list_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_benign_list function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_benign_list(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.display_hour_range"><code class="name flex">
<span>def <span class="ident">display_hour_range</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the hour range input or hides depending on the
time radio button selected.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the time radio button option selected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the hour range or hide it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_hour_range(value):
    &#34;&#34;&#34;

    Function that either displays the hour range input or hides depending on the
    time radio button selected.

    Args:
        value: Contains the time radio button option selected.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the hour range or hide it.

    &#34;&#34;&#34;

    if value is None or value == &#39;Day&#39;:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.display_hour_range_dash"><code class="name flex">
<span>def <span class="ident">display_hour_range_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the display_hour_range function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;hour_range&#39;, &#39;style&#39;),
              [Input(&#39;requests_freq&#39;, &#39;value&#39;)])
def display_hour_range_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_hour_range function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_hour_range(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.display_mal_graph"><code class="name flex">
<span>def <span class="ident">display_mal_graph</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the graph of the top 20 malicious domains or
hides them depending on the position of the toggle switch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the graph of the top 20 malicious domains or hide them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_mal_graph(value):
    &#34;&#34;&#34;

    Function that either displays the graph of the top 20 malicious domains or
    hides them depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the graph of the top 20 malicious domains or hide them.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;unset&#39;}
    else:
        return {&#39;display&#39;: &#39;none&#39;}</code></pre>
</details>
</dd>
<dt id="ui.display_mal_graph_dash"><code class="name flex">
<span>def <span class="ident">display_mal_graph_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the display_mal_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;mal_bar_graph_div&#39;, &#39;style&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;)])
def display_mal_graph_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_mal_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_mal_graph(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.display_mal_list"><code class="name flex">
<span>def <span class="ident">display_mal_list</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the list of malicious domains or hides them
depending on the position of the toggle switch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the list of malicious domains or hide them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_mal_list(value):
    &#34;&#34;&#34;

    Function that either displays the list of malicious domains or hides them
    depending on the position of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the list of malicious domains or hide them.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.display_mal_list_dash"><code class="name flex">
<span>def <span class="ident">display_mal_list_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the display_mal_list function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;mal_dns_table_div&#39;, &#39;style&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;)])
def display_mal_list_dash(value):
    &#34;&#34;&#34;

    Function that just calls the display_mal_list function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = display_mal_list(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.hour_range_message"><code class="name flex">
<span>def <span class="ident">hour_range_message</span></span>(<span>freq, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a message when the user selects options for historical
analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freq</code></strong></dt>
<dd>Radio option for selecting the requests per day, hour, minute.</dd>
<dt><strong><code>start</code></strong></dt>
<dd>Start time for the historical analysis.</dd>
<dt><strong><code>end</code></strong></dt>
<dd>End time for the historical analysis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A message to the user as a response to the the inputs for obtaining
the historical analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hour_range_message(freq, start, end):
    &#34;&#34;&#34;

    Function that returns a message when the user selects options for historical
    analysis.


    Args:
        freq: Radio option for selecting the requests per day, hour, minute.
        start: Start time for the historical analysis.
        end: End time for the historical analysis.

    Returns:
        A message to the user as a response to the the inputs for obtaining
        the historical analysis.

    &#34;&#34;&#34;

    if freq is None or freq == &#39;Day&#39;:
        return html.Div([])
    elif start is None or start is &#39;&#39; or end is None or end is &#39;&#39;:
        return &#39;Enter an integer hour range (0 to 24)&#39;
    else:
        try:
            start_ = int(start)
            end_ = int(end)
            diff = end_ - start_
            if 0 &lt;= start_ &lt;= 24 and 0 &lt;= end_ &lt;= 24 and diff &gt; 0:
                if freq == &#39;Minute&#39;:
                    if diff &gt; 1:
                        return &#39;The difference between the ranges should be 1&#39;
                    else:
                        return &#39;Hour range from {} to {}&#39;.format(start_, end_)
                else:
                    return &#39;Hour range from {} to {}&#39;.format(start_, end_)
            else:
                return &#39;Please enter relevant integer values (0 to 24) &#39;
        except:
            return &#39;Please enter integer values (0 to 24)&#39;</code></pre>
</details>
</dd>
<dt id="ui.hour_range_message_dash"><code class="name flex">
<span>def <span class="ident">hour_range_message_dash</span></span>(<span>freq, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the hour_range_message function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;hour_range_message&#39;, &#39;children&#39;),
              [Input(&#39;requests_freq&#39;, &#39;value&#39;),
               Input(&#39;start_hour&#39;, &#39;value&#39;),
               Input(&#39;end_hour&#39;, &#39;value&#39;)])
def hour_range_message_dash(freq, start, end):
    &#34;&#34;&#34;

    Function that just calls the hour_range_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    hour_range_message_ = hour_range_message(freq, start, end)
    return hour_range_message_</code></pre>
</details>
</dd>
<dt id="ui.input_message"><code class="name flex">
<span>def <span class="ident">input_message</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a message when a domain name is entered.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The domain name that is entered by the user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A message as a response to the user as the result of an input for the
domain name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_message(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a message when a domain name is entered.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        value: The domain name that is entered by the user.

    Returns:
        A message as a response to the user as the result of an input for the
        domain name.

    &#34;&#34;&#34;

    try:
        keys = es.indices.get(&#39;*&#39;).keys()
    except:
        keys = []
    if value is None or value == &#39;&#39;:
        return &#39;Please enter a Domain Name&#39;
    elif value in keys:
        return &#39;You have entered: &#39; + value
    else:
        return &#39;Domain Name does not exist in Database&#39;</code></pre>
</details>
</dd>
<dt id="ui.input_message_dash"><code class="name flex">
<span>def <span class="ident">input_message_dash</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the input_message function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;input_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def input_message_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the input_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    return_input_message = input_message(n_clicks, value)
    return return_input_message</code></pre>
</details>
</dd>
<dt id="ui.radio_button_message"><code class="name flex">
<span>def <span class="ident">radio_button_message</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a message when the user selects a radio button.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The radio button option selected by the user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A message to the user as a response to the radio button input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radio_button_message(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a message when the user selects a radio button.

    Args:
        n_clicks: Number of clicks registered by the submit button.
        value: The radio button option selected by the user.

    Returns:
        A message to the user as a response to the radio button input.

    &#34;&#34;&#34;

    if value is None:
        return &#39;Please select an option&#39;
    else:
        return &#39;You have selected: &#39; + value</code></pre>
</details>
</dd>
<dt id="ui.radio_button_message_dash"><code class="name flex">
<span>def <span class="ident">radio_button_message_dash</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the radio_button_message function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;radio_button_message&#39;, &#39;children&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;requests_freq&#39;, &#39;value&#39;)])
def radio_button_message_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the radio_button_message function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    radio_button_message_ = radio_button_message(n_clicks, value)
    return radio_button_message_</code></pre>
</details>
</dd>
<dt id="ui.update_acc_graph"><code class="name flex">
<span>def <span class="ident">update_acc_graph</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a line graph of the accuracy graph (accuracy
percentage vs epochs) of the deep learning model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name that is currently being trained or is
an older model whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An accuracy graph of the deep learning model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_acc_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a line graph of the accuracy graph (accuracy
    percentage vs epochs) of the deep learning model.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the model name that is currently being trained or is
               an older model whose efficacy has to be investigated.

    Returns:
        An accuracy graph of the deep learning model.

    &#34;&#34;&#34;

    layout_loss = copy.deepcopy(layout)
    layout_loss[&#39;title&#39;] = &#39;Accuracy Graph&#39;
    layout_loss[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Epochs&#39;}
    layout_loss[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Accuracy %&#39;}
    layout_loss[&#39;autosize&#39;] = False
    layout_loss[&#39;height&#39;] = &#39;400&#39;
    layout_loss[&#39;width&#39;] = &#39;850&#39;
    layout_loss[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=0),
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 1) or \
            (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1):
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_acc&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_acc_graph_dash"><code class="name flex">
<span>def <span class="ident">update_acc_graph_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_acc_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;acc_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_acc_graph_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_acc_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_acc_graph(n_clicks, value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_and_input_vet_message_vet_tables"><code class="name flex">
<span>def <span class="ident">update_and_input_vet_message_vet_tables</span></span>(<span>n_clicks, not_vetted_select, benign_vet_select, honeypot_vet_select, blacklist_vet_select, change_status)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a message regarding the options selected for manually
vetting domain names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>not_vetted_select</code></strong></dt>
<dd>Contains the list of domains that have been selected
for vetting from the list of non - vetted domains.</dd>
<dt><strong><code>benign_vet_select</code></strong></dt>
<dd>Contains the list of domains that have been selected
for a list change from the list of benign domains.</dd>
<dt><strong><code>honeypot_vet_select</code></strong></dt>
<dd>Contains the list of domains that have been selected
for a list change from the list of honeypot domains.</dd>
<dt><strong><code>blacklist_vet_select</code></strong></dt>
<dd>Contains the list of domains that have been selected
for a list change from the list of malicious domains.</dd>
<dt><strong><code>change_status</code></strong></dt>
<dd>Radio button that contains option of the list the domains
selected have to be changed to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A message regarding the options selected for manually vetting domain
names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_and_input_vet_message_vet_tables(n_clicks, not_vetted_select,
                                            benign_vet_select,
                                            honeypot_vet_select,
                                            blacklist_vet_select,
                                            change_status):
    &#34;&#34;&#34;

    Function that returns a message regarding the options selected for manually
    vetting domain names.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        not_vetted_select: Contains the list of domains that have been selected
                           for vetting from the list of non - vetted domains.
        benign_vet_select: Contains the list of domains that have been selected
                           for a list change from the list of benign domains.
        honeypot_vet_select: Contains the list of domains that have been selected
                             for a list change from the list of honeypot domains.
        blacklist_vet_select: Contains the list of domains that have been selected
                              for a list change from the list of malicious domains.
        change_status: Radio button that contains option of the list the domains
                       selected have to be changed to.

    Returns:
        A message regarding the options selected for manually vetting domain
        names.

    &#34;&#34;&#34;

    vet_list = [not_vetted_select, benign_vet_select, honeypot_vet_select,
                blacklist_vet_select]
    es_vet_list_names = [&#39;not_vetted&#39;, &#39;benign_vet&#39;, &#39;honeypot&#39;, &#39;blacklist&#39;]
    if change_status is None:
        for i in vet_list:
            if i is not None and i != []:
                return &#39;Please select the option, the entries have to be &#39; \
                       &#39;changed to.&#39;, None, None, None, None, None
        return &#39;Please select the entries on the left whose status has to be &#39; \
               &#39;changed and also select the option, the entries have to be &#39; \
               &#39;changed to.&#39;, None, None, None, None, None
    else:
        for i, j in zip(vet_list, es_vet_list_names):
            if i is not None and i != []:
                if change_status in j:
                    return &#39;Please enter a different option to change the &#39; \
                           &#39;status.&#39;, None, None, None, None, None
                else:
                    body_to_change = es.get(index=j, id=1)[&#39;_source&#39;]
                    body_to_change_keys = \
                        list(es.get(index=j, id=1)[&#39;_source&#39;].keys())

                    for k in i:
                        body_to_update = \
                            {&#39;doc&#39;:
                                 {body_to_change_keys[k]:
                                      body_to_change[body_to_change_keys[k]]}}
                        es.update(index=change_status, id=1, body=body_to_update)

                    for k in i:
                        del (body_to_change[body_to_change_keys[k]])
                    es.index(j, id=1, body=body_to_change)
                    return &#39;Status change successful.&#39;, \
                           None, None, None, None, None

        return &#39;Please select the entries on the left whose status has to be &#39; \
               &#39;changed.&#39;, None, None, None, None, None</code></pre>
</details>
</dd>
<dt id="ui.update_and_input_vet_message_vet_tables_dash"><code class="name flex">
<span>def <span class="ident">update_and_input_vet_message_vet_tables_dash</span></span>(<span>n_clicks, not_vetted_select, benign_vet_select, honeypot_vet_select, blacklist_vet_select, change_status)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_and_input_vet_message_vet_tables
function. This function is decorated by the Dash Application decorator. Such
an arrangement is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback([Output(&#39;input_vet_message&#39;, &#39;children&#39;),
               Output(&#39;change_status&#39;, &#39;value&#39;),
               Output(&#39;not_vetted_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;benign_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;honeypot_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               Output(&#39;blacklist_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;)],
              [Input(&#39;submit_vet_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;not_vetted_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;benign_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;honeypot_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;blacklist_vet_table&#39;, &#34;derived_viewport_selected_rows&#34;),
               State(&#39;change_status&#39;, &#39;value&#39;), ])
def update_and_input_vet_message_vet_tables_dash(n_clicks, not_vetted_select,
                                                 benign_vet_select,
                                                 honeypot_vet_select,
                                                 blacklist_vet_select,
                                                 change_status):
    &#34;&#34;&#34;

    Function that just calls the update_and_input_vet_message_vet_tables
    function. This function is decorated by the Dash Application decorator. Such
    an arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    message, _, _, _, _, _ = update_and_input_vet_message_vet_tables(n_clicks,
                                                                     not_vetted_select,
                                                                     benign_vet_select,
                                                                     honeypot_vet_select,
                                                                     blacklist_vet_select,
                                                                     change_status)
    return message, None, None, None, None, None</code></pre>
</details>
</dd>
<dt id="ui.update_benign_bar_graph"><code class="name flex">
<span>def <span class="ident">update_benign_bar_graph</span></span>(<span>value, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a bar graph of the top 20 benign domains.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>Contains the interval after which the figure should be
refreshed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A bar graph that contains the top benign domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_benign_bar_graph(value, interval):
    &#34;&#34;&#34;

    Function that returns a bar graph of the top 20 benign domains.

    Args:
        value: Contains the value of the toggle switch
        interval: Contains the interval after which the figure should be
                  refreshed.

    Returns:
        A bar graph that contains the top benign domains.

    &#34;&#34;&#34;
    
    try:
        benign = es.get(index=&#39;benign&#39;, id=1)[&#39;_source&#39;]
    except:
        benign = {}
    if len(benign) &lt; 20:
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
    else:
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)][0:20]

    layout_bar = copy.deepcopy(layout)
    layout_bar[&#39;title&#39;] = &#34;Top Benign Domains Queried&#34;
    layout_bar[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Rank (Hover over the bars for more info)&#39;,
                           &#39;tickvals&#39;: [(i + 1) for i in
                                        range(len(domain_names))]}
    layout_bar[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_bar[&#39;margin&#39;] = dict(l=30, r=30, b=20, t=30),
    layout_bar[&#39;height&#39;] = &#39;400&#39;
    data = [
        dict(
            type=&#34;bar&#34;,
            hovertext=domain_names,
            x=[(i + 1) for i in range(len(domain_names))],
            y=[int(benign[i][&#39;count&#39;]) for i in domain_names],
        )]
    figure = dict(data=data, layout=layout_bar)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_benign_bar_graph_dash"><code class="name flex">
<span>def <span class="ident">update_benign_bar_graph_dash</span></span>(<span>value, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_benign_bar_graph function. This function
is decorated by the Dash Application decorator. Such an arrangement is used
as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;benign_bar_graph&#39;, &#39;figure&#39;),
              [Input(&#39;benign_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_bar_graph_dash(value, interval):
    &#34;&#34;&#34;

    Function that just calls the update_benign_bar_graph function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_benign_bar_graph(value, interval)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_benign_dns_table"><code class="name flex">
<span>def <span class="ident">update_benign_dns_table</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the data that contains the list of benign domains.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nclicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Data that contains the list of benign domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_benign_dns_table(nclicks, value):
    &#34;&#34;&#34;

    Function that returns the data that contains the list of benign domains.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the value of the toggle switch.

    Returns:
        Data that contains the list of benign domains.

    &#34;&#34;&#34;

    try:
        benign = es.get(index=&#39;benign&#39;, id=1)[&#39;_source&#39;]
        domain_names = [key for (key, value) in
                        sorted(benign.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;acc&#39;: benign[i][&#39;status&#39;], &#39;count&#39;: benign[i][&#39;count&#39;]})
                for i, j in zip(domain_names, range(len(benign)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_benign_dns_table_dash"><code class="name flex">
<span>def <span class="ident">update_benign_dns_table_dash</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_benign_dns_table function. This function
is decorated by the Dash Application decorator. Such an arrangement is used
as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;benign_dns_table&#39;, &#39;data&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_dns_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_benign_dns_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_benign_dns_table(nclicks, value)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_benign_vet_table"><code class="name flex">
<span>def <span class="ident">update_benign_vet_table</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the updated data of the list of benign domains after a
specific interval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_intervals</code></strong></dt>
<dd>Contains the interval after which the data has to be updated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated data of the list of benign domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_benign_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of benign domains after a
    specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of benign domains.

    &#34;&#34;&#34;

    try:
        benign_vet = es.get(index=&#39;benign_vet&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: benign_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: benign_vet[i][&#39;acc&#39;]})
                for i, j in zip(benign_vet.keys(), range(len(benign_vet)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_benign_vet_table_dash"><code class="name flex">
<span>def <span class="ident">update_benign_vet_table_dash</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_benign_vet_table function. This function
is decorated by the Dash Application decorator. Such an arrangement is used
as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;benign_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_benign_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_benign_vet_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_benign_vet_table(n_intervals)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_blacklist_vet_table"><code class="name flex">
<span>def <span class="ident">update_blacklist_vet_table</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the updated data of the list of malicious domains
after a specific interval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_intervals</code></strong></dt>
<dd>Contains the interval after which the data has to be updated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated data of the list of malicious domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_blacklist_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of malicious domains
    after a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of malicious domains.

    &#34;&#34;&#34;

    try:
        blacklist_vet = es.get(index=&#39;blacklist&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: blacklist_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: blacklist_vet[i][&#39;acc&#39;]})
                for i, j in zip(blacklist_vet.keys(),
                                range(len(blacklist_vet)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_blacklist_vet_table_dash"><code class="name flex">
<span>def <span class="ident">update_blacklist_vet_table_dash</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_blacklist_vet_table function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;blacklist_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_blacklist_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_blacklist_vet_table function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_blacklist_vet_table(n_intervals)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_test"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_test</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion matrix of the model after training on the test dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confusion matrix of the trained model on the test dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_matrix_test(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the test dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the test dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_test&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_test&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_test_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_test_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_matrix_test function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_test&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_test_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_test function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_test(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_training"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_training</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion matrix of the model after training on the training
dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confusion matrix of the trained model on the training dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_matrix_training(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the training
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the training dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_train&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_train&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)

    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_training_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_training_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_matrix_training function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_training&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_training_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_training function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_training(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_validation"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_validation</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion matrix of the model after training on the validation
dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A confusion matrix of the trained model on the validation dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_matrix_validation(value):
    &#34;&#34;&#34;

    Returns the confusion matrix of the model after training on the validation
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          A confusion matrix of the trained model on the validation dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion)
    layout_confusion[&#39;height&#39;] = 230
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[go.Heatmap(
            z=[[0, 100], [100, 0]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_valid&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        conf = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;cf_matrix_valid&#39;]
        figure = go.Figure(data=[go.Heatmap(
            z=[[conf[0][1], conf[0][0]], [conf[1][1], conf[1][0]]],
            x=[&#39;False&#39;, &#39;True&#39;],
            y=[&#39;True&#39;, &#39;False&#39;],
            text=[[&#39;FN&#39;, &#39;TP&#39;], [&#39;TN&#39;, &#39;FP&#39;]],
            colorscale=[[0, &#39;rgb(226,239,248)&#39;], [1.0, &#39;rgb(84,162,214)&#39;]],
            hoverongaps=False)],
            layout=layout_confusion)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_matrix_validation_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_matrix_validation_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_matrix_validation function.
This function is decorated by the Dash Application decorator. Such an
arrangement is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_validation&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_matrix_validation_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_matrix_validation function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_matrix_validation(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_test"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_test</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion metrics of the model after training on the test
dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Confusion metrics of the trained model on the test dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_metrics_test(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the test
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the test dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_test&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_test&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_test&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_test&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39; \
                                                &#39;&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_test&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_test&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_test&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_test&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_test_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_test_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_metrics_test function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_met_test&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_test_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_test function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_test(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_training"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_training</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion metrics of the model after training on the training
dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Confusion metrics of the trained model on the training dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_metrics_training(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the training
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the training dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_train&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_train&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_train&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_train&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_train&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_train&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_train&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_train&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_training_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_training_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_metrics_training function.
This function is decorated by the Dash Application decorator. Such an
arrangement is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_met_training&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_training_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_training function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_training(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_validation"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_validation</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the confusion metrics of the model after training on the validation
dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Confusion metrics of the trained model on the validation dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_confusion_metrics_validation(value):
    &#34;&#34;&#34;

    Returns the confusion metrics of the model after training on the validation
    dataset.

    Args:
        value: Contains the model name whose efficacy has to be investigated.

    Returns:
          Confusion metrics of the trained model on the validation dataset.

    &#34;&#34;&#34;

    layout_confusion = copy.deepcopy(layout_training_confusion_met)
    layout_confusion[&#39;height&#39;] = 200
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[0.5],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_valid&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_valid&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_valid&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_valid&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        model_name = es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;]
        acc = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;acc_valid&#39;]
        pres = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;pres_valid&#39;]
        rec = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;rec_valid&#39;]
        f1 = es.get(index=model_name, id=1)[&#39;_source&#39;][&#39;metrics&#39;][&#39;f1_valid&#39;]
        figure = go.Figure(data=[
            go.Bar(name=&#39;Accuracy&#39;, x=[&#39;Score&#39;], y=[acc],
                   marker_color=&#39;rgb(226,239,248)&#39;),
            go.Bar(name=&#39;Precision&#39;, x=[&#39;Score&#39;], y=[pres],
                   marker_color=&#39;rgb(179,214,237)&#39;),
            go.Bar(name=&#39;Recall&#39;, x=[&#39;Score&#39;], y=[rec],
                   marker_color=&#39;rgb(131,188,225)&#39;),
            go.Bar(name=&#39;F1 Score&#39;, x=[&#39;Score&#39;], y=[f1],
                   marker_color=&#39;rgb(84,162,214)&#39;),
        ],
            layout=layout_confusion)
        figure[&#39;layout&#39;][&#39;yaxis1&#39;].update(title=&#39;&#39;, range=[0, 1], dtick=0.5,
                                          autorange=False)

    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_confusion_metrics_validation_dash"><code class="name flex">
<span>def <span class="ident">update_confusion_metrics_validation_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_confusion_metrics_validation function.
This function is decorated by the Dash Application decorator. Such an
arrangement is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;confusion_met_validation&#39;, &#39;figure&#39;),
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_confusion_metrics_validation_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_confusion_metrics_validation function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_confusion_metrics_validation(value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_display_training_options"><code class="name flex">
<span>def <span class="ident">update_display_training_options</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the input fields required to be filled in by
the user for training or hides them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary that communicates with the Dash interface whether to
display the input fields required to be filled in by the user for
training or hide them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_display_training_options(value):
    &#34;&#34;&#34;

    Function that either displays the input fields required to be filled in by
    the user for training or hides them.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        A dictionary that communicates with the Dash interface whether to
        display the input fields required to be filled in by the user for
        training or hide them.

    &#34;&#34;&#34;

    if value is None or value == &#39;load&#39;:
        return {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.update_display_training_options_dash"><code class="name flex">
<span>def <span class="ident">update_display_training_options_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_display_training_options function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;training_options&#39;, &#39;style&#39;),
              [Input(&#39;model_option&#39;, &#39;value&#39;)])
def update_display_training_options_dash(value):
    &#34;&#34;&#34;

    Function that just calls the update_display_training_options function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display = update_display_training_options(value)
    return display</code></pre>
</details>
</dd>
<dt id="ui.update_es_parameters_and_messages"><code class="name flex">
<span>def <span class="ident">update_es_parameters_and_messages</span></span>(<span>model_name, option, epochs_input, batch_input, sample_input)</span>
</code></dt>
<dd>
<div class="desc"><p>Functions that updates model training information in the Elasticsearch
Database and also returns messages for the data entered by the user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_name</code></strong></dt>
<dd>Contains the model name entered by the user.</dd>
<dt><strong><code>option</code></strong></dt>
<dd>Contains the option whether to train a new model or display the
statistics that explain the efficacy of an older model.</dd>
<dt><strong><code>epochs_input</code></strong></dt>
<dd>Contains the number of epochs entered for training by the
user.</dd>
<dt><strong><code>batch_input</code></strong></dt>
<dd>Contains the batch size entered for training by the user.</dd>
<dt><strong><code>sample_input</code></strong></dt>
<dd>Contains the sample size entered for training by the user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Messages to the user as a response to the options filled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_es_parameters_and_messages(model_name, option, epochs_input,
                                      batch_input, sample_input):
    &#34;&#34;&#34;

    Functions that updates model training information in the Elasticsearch
    Database and also returns messages for the data entered by the user.

    Args:
        model_name: Contains the model name entered by the user.
        option: Contains the option whether to train a new model or display the
                statistics that explain the efficacy of an older model.
        epochs_input: Contains the number of epochs entered for training by the
                      user.
        batch_input: Contains the batch size entered for training by the user.
        sample_input: Contains the sample size entered for training by the user.

    Returns:
        Messages to the user as a response to the options filled.

    &#34;&#34;&#34;

    model_message = &#39;Please enter a model name&#39;
    epochs_message = &#39;Please enter an integer value&#39;
    batch_message = &#39;Please enter an integer value&#39;
    sample_message = &#39;Please enter an integer value&#39;
    model_check, option_check = False, False
    epochs_check, batch_check, sample_check = False, False, False

    if (model_name is not None) and (model_name != &#39;&#39;):
        model_check = True
    if option is not None:
        option_check = True

    if (not model_check) and (not option_check):
        model_message = &#39;Enter model name and option&#39;
    elif model_check and (not option_check):
        model_message = &#39;Please enter an option&#39;
    elif (not model_check) and option_check:
        model_message = &#39;Please enter a model name&#39;
    else:
        if option == &#39;load&#39;:
            models = \
                glob.glob(&#39;../../../mlbridge-machine-learning/saved_models/*.hdf5&#39;)
            for i in models:
                name = i.replace(&#39;\\&#39;, &#39;/&#39;)
                name = name.split(&#39;/&#39;)
                name.reverse()
                if model_name == name[0].split(&#39;.&#39;)[0]:
                    update_body = {&#39;doc&#39;: {&#39;name&#39;: model_name,
                                           &#39;training&#39;: 0, &#39;load&#39;: 1, &#39;batch&#39;: 0,
                                           &#39;epochs&#39;: 0, &#39;samples&#39;: 0}}
                    try:
                        es.update(index=&#39;model&#39;, id=1, body=update_body)
                        model_message = &#39;Model Loaded&#39;
                    except:
                        model_message = &#39;Model Loaded&#39;
                else:
                    model_message = &#39;Model does not exist&#39;

        elif option == &#39;training&#39;:

            if (epochs_input is None) or (epochs_input == &#39;&#39;):
                epochs_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    epochs = int(epochs_input)
                    if epochs &gt; 0:
                        epochs_check = True
                        epochs_message = &#39;You have entered &#39; + str(epochs) + &#39; epochs&#39;
                    else:
                        epochs_message = &#39;Please enter a value greater than 0&#39;
                except:
                    epochs_message = &#39;Please enter an integer value&#39;

            if (batch_input is None) or (batch_input == &#39;&#39;):
                batch_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    batch = int(batch_input)
                    if batch &gt; 0:
                        batch_check = True
                        batch_message = &#39;Entered batch-size &#39; + str(batch)
                    else:
                        batch_message = &#39;Please enter a value greater than 0&#39;
                except:
                    batch_message = &#39;Please enter an integer value&#39;

            if (sample_input is None) and (sample_input == &#39;&#39;):
                sample_message = &#39;Please enter an integer value&#39;
            else:
                try:
                    samples = int(sample_input)
                    if samples &gt; 0:
                        sample_check = True
                        sample_message = &#39;Entered &#39; + str(sample_input) + &#39; samples&#39;
                    else:
                        sample_message = &#39;Please enter a value greater than 0&#39;
                except:
                    sample_message = &#39;Please enter an integer value&#39;

            if epochs_check and batch_check and sample_check:
                try:
                    update_body = {&#39;doc&#39;: {&#39;name&#39;: model_name,
                                           &#39;training&#39;: 1, &#39;load&#39;: 0,
                                           &#39;batch&#39;: batch, &#39;epochs&#39;: epochs,
                                           &#39;samples&#39;: samples}}
                    es.update(index=&#39;model&#39;, id=1, body=update_body)
                    model_message = &#39;Training the model&#39;
                except:
                    model_message = &#39;Issue with Elasticsearch&#39;

    return model_message, epochs_message, batch_message, sample_message</code></pre>
</details>
</dd>
<dt id="ui.update_es_parameters_and_messages_dash"><code class="name flex">
<span>def <span class="ident">update_es_parameters_and_messages_dash</span></span>(<span>n_clicks, option, model, epochs, batch, samples)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_es_parameters_and_messages function.
This function is decorated by the Dash Application decorator. Such an
arrangement is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback([Output(&#39;input_model_message&#39;, &#39;children&#39;),
               Output(&#39;epoch_message&#39;, &#39;children&#39;),
               Output(&#39;batch_message&#39;, &#39;children&#39;),
               Output(&#39;sample_message&#39;, &#39;children&#39;)],
              [Input(&#39;submit_model&#39;, &#39;n_clicks&#39;)],
              [State(&#39;model_option&#39;, &#39;value&#39;),
               State(&#39;input_model&#39;, &#39;value&#39;),
               State(&#39;input_epochs&#39;, &#39;value&#39;),
               State(&#39;input_batch&#39;, &#39;value&#39;),
               State(&#39;input_sample&#39;, &#39;value&#39;)])
def update_es_parameters_and_messages_dash(n_clicks, option, model, epochs,
                                           batch, samples):
    &#34;&#34;&#34;

    Function that just calls the update_es_parameters_and_messages function.
    This function is decorated by the Dash Application decorator. Such an
    arrangement is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    model_message, epochs_message, batch_message, samples_message \
        = update_es_parameters_and_messages(model, option, epochs, batch, samples)
    return model_message, epochs_message, batch_message, samples_message</code></pre>
</details>
</dd>
<dt id="ui.update_honeypot_vet_table"><code class="name flex">
<span>def <span class="ident">update_honeypot_vet_table</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the updated data of the list of honeypot domains after
a specific interval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_intervals</code></strong></dt>
<dd>Contains the interval after which the data has to be updated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated data of the list of honeypot domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_honeypot_vet_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of honeypot domains after
    a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of honeypot domains.

    &#34;&#34;&#34;

    try:
        honeypot_vet = es.get(index=&#39;honeypot&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: honeypot_vet[i][&#39;class&#39;],
                      &#39;acc&#39;: honeypot_vet[i][&#39;acc&#39;]})
                for i, j in zip(honeypot_vet.keys(), range(len(honeypot_vet)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_honeypot_vet_table_dash"><code class="name flex">
<span>def <span class="ident">update_honeypot_vet_table_dash</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_honeypot_vet_table function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;honeypot_vet_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_honeypot_vet_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_honeypot_vet_table function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_honeypot_vet_table(n_intervals)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_ip_table"><code class="name flex">
<span>def <span class="ident">update_ip_table</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that updates the IP table in the Elasticsearch Database that
contains the frequency as well as the IP address of the machine querying
that particular domain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nclicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the domain name corresponding to which the IP table has
to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The IP address data regarding the number of times a particular domain
was queried by a particular machine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ip_table(nclicks, value):
    &#34;&#34;&#34;

    Function that updates the IP table in the Elasticsearch Database that
    contains the frequency as well as the IP address of the machine querying
    that particular domain.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the domain name corresponding to which the IP table has
               to be returned.

    Returns:
        The IP address data regarding the number of times a particular domain
        was queried by a particular machine.

    &#34;&#34;&#34;

    if value is None or value == &#39;&#39;:
        return []
    else:
        try:
            count = es.get(index=value, id=1)[&#39;_source&#39;][&#39;count&#39;]
            domain_names = [key for (key, value) in sorted(count.items(),
                                                           key=lambda x: x[1],
                                                           reverse=True)]
            data = [dict({&#39;sl_no&#39;: j + 1, &#39;ip&#39;: i, &#39;count&#39;: count[i]})
                    for i, j in zip(domain_names, range(len(count)))]
        except:
            data = []
        return data</code></pre>
</details>
</dd>
<dt id="ui.update_ip_table_dash"><code class="name flex">
<span>def <span class="ident">update_ip_table_dash</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_ip_table function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;ip_table_&#39;, &#39;data&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_ip_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_ip_table function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_ip_table(nclicks, value)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_line_graph"><code class="name flex">
<span>def <span class="ident">update_line_graph</span></span>(<span>n_clicks, start_hour, end_hour, input_value, start_date, end_date, freq_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that updates the line graph that displays the frequency, the time
as well as the date when that particular domain name was queried.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>start_hour</code></strong></dt>
<dd>Contains the start the of the hour range between which the
frequency of the domain name queried would be investigated.</dd>
<dt><strong><code>end_hour</code></strong></dt>
<dd>Contains the end the of the hour range between which frequency
of the domain name queried would be investigated.</dd>
<dt><strong><code>input_value</code></strong></dt>
<dd>Contains the domain name that has to be investigated.</dd>
<dt><strong><code>start_date</code></strong></dt>
<dd>Contains the start the of the date range between which the
frequency of the domain name queried would be investigated.</dd>
<dt><strong><code>end_date</code></strong></dt>
<dd>Contains the end the of the hour range between which the
frequency of the domain name queried would be investigated.</dd>
<dt><strong><code>freq_value</code></strong></dt>
<dd>Contains the value of the time radio button selected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A line graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_line_graph(n_clicks, start_hour, end_hour, input_value,
                      start_date, end_date, freq_value):
    &#34;&#34;&#34;

    Function that updates the line graph that displays the frequency, the time
    as well as the date when that particular domain name was queried.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        start_hour: Contains the start the of the hour range between which the
                    frequency of the domain name queried would be investigated.
        end_hour: Contains the end the of the hour range between which frequency
                  of the domain name queried would be investigated.
        input_value: Contains the domain name that has to be investigated.
        start_date: Contains the start the of the date range between which the
                    frequency of the domain name queried would be investigated.
        end_date: Contains the end the of the hour range between which the
                  frequency of the domain name queried would be investigated.
        freq_value: Contains the value of the time radio button selected.

    Returns:
        A line graph.

    &#34;&#34;&#34;

    layout_count = copy.deepcopy(layout)
    layout_count[&#39;title&#39;] = &#34;Requests&#34;
    if freq_value is None:
        freq_value = &#39;&#39;
    layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Time in &#39; + freq_value + &#39;s&#39;}
    layout_count[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_count[&#39;autosize&#39;] = True
    layout_count[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=30),
    if input_value is None or input_value == &#39;&#39; or start_date is None or \
            end_date is None or freq_value is None:
        layout_count[&#39;title&#39;] = &#34;Requests (Please fill the entries)&#34;
        layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
        data = [
            dict(
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[],
                y=[],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            )]
        figure = dict(data=data, layout=layout_count)
        return figure
    else:
        if freq_value == &#39;Minute&#39;:
            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;][start_date][start_hour]
                x = [i for i in req.keys()]
                y = [i for i in req.values()]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure
        elif freq_value == &#39;Hour&#39;:
            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;][start_date]
                hours = [str(i) for i in range(int(start_hour), int(end_hour))]
                x = list(set(hours) &amp; set(req.keys()))
                y = [np.sum(list(req[i].values())) for i in x]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure
        elif freq_value == &#39;Day&#39;:
            start = start_date.split(&#39;-&#39;)
            start[1], start[2] = start[1].lstrip(&#39;0&#39;), start[2].lstrip(&#39;0&#39;)
            end = end_date.split(&#39;-&#39;)
            end[1], end[2] = end[1].lstrip(&#39;0&#39;), end[2].lstrip(&#39;0&#39;)

            try:
                req = es.get(index=input_value, id=1)[&#39;_source&#39;]
                req = req[start[0]][start[1]]
                print(req)
                if (int(end[1]) - int(start[1])) == 0:
                    days = [str(i) for i in range(int(start[2]),
                                                  (int(end[2]) + 1))]

                    x = list(set(days) &amp; set(req.keys()))
                    y = [req[i] for i in x]
                else:
                    x = [i for i in req.keys()]
                    y = [req[i] for i in x]
            except:
                layout_count[&#39;title&#39;] = &#34;Requests (Data not found)&#34;
                layout_count[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;&#39;}
                x = []
                y = []
            data = [
                dict(
                    type=&#34;line&#34;,
                    x=x,
                    y=y,
                )]
            figure = dict(data=data, layout=layout_count)
            return figure</code></pre>
</details>
</dd>
<dt id="ui.update_line_graph_dash"><code class="name flex">
<span>def <span class="ident">update_line_graph_dash</span></span>(<span>n_clicks, start_hour, end_hour, input_value, start_date, end_date, freq_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_line_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;freq_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;), ],
              [State(&#39;start_hour&#39;, &#39;value&#39;),
               State(&#39;end_hour&#39;, &#39;value&#39;),
               State(&#39;input_text&#39;, &#39;value&#39;),
               State(&#39;date_range&#39;, &#39;start_date&#39;),
               State(&#39;date_range&#39;, &#39;end_date&#39;),
               State(&#39;requests_freq&#39;, &#39;value&#39;)])
def update_line_graph_dash(n_clicks, start_hour, end_hour, input_value,
                           start_date, end_date, freq_value):
    &#34;&#34;&#34;

    Function that just calls the update_line_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_line_graph(n_clicks, start_hour, end_hour, input_value,
                               start_date, end_date, freq_value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_loss_accuracy_display"><code class="name flex">
<span>def <span class="ident">update_loss_accuracy_display</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that either displays the loss graph or the accuracy graph of the
deep learning model depending on the value of the toggle switch.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Two dictionaries that communicates with the Dash interface whether to
display the accuracy graph or loss graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_loss_accuracy_display(value):
    &#34;&#34;&#34;

    Function that either displays the loss graph or the accuracy graph of the
    deep learning model depending on the value of the toggle switch.

    Args:
        value: Contains the value of the toggle switch.

    Returns:
        Two dictionaries that communicates with the Dash interface whether to
        display the accuracy graph or loss graph.

    &#34;&#34;&#34;

    if value is False:
        return {&#39;display&#39;: &#39;unset&#39;}, {&#39;display&#39;: &#39;none&#39;}
    else:
        return {&#39;display&#39;: &#39;none&#39;}, {&#39;display&#39;: &#39;unset&#39;}</code></pre>
</details>
</dd>
<dt id="ui.update_loss_accuracy_display_dash"><code class="name flex">
<span>def <span class="ident">update_loss_accuracy_display_dash</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_loss_accuracy_display function. This
function is decorated by the Dash Application decorator. Such an arrangement
is used as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback([Output(&#39;loss_graph&#39;, &#39;style&#39;),
               Output(&#39;acc_graph&#39;, &#39;style&#39;)],
              [Input(&#39;train_switch&#39;, &#39;value&#39;)])
def update_loss_accuracy_display_dash(value):
    &#34;&#34;&#34;

    Function that just calls the update_loss_accuracy_display function. This
    function is decorated by the Dash Application decorator. Such an arrangement
    is used as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    display_loss, display_acc = update_loss_accuracy_display(value)
    return display_loss, display_acc</code></pre>
</details>
</dd>
<dt id="ui.update_loss_graph"><code class="name flex">
<span>def <span class="ident">update_loss_graph</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a line graph of the loss graph (loss percentage vs
epochs) of the deep learning model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the model name that is currently being trained or is
an older model whose efficacy has to be investigated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A loss graph of the deep learning model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_loss_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a line graph of the loss graph (loss percentage vs
    epochs) of the deep learning model.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the model name that is currently being trained or is
               an older model whose efficacy has to be investigated.

    Returns:
        A loss graph of the deep learning model.

    &#34;&#34;&#34;

    layout_loss = copy.deepcopy(layout)
    layout_loss[&#39;title&#39;] = &#39;Loss Graph&#39;
    layout_loss[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Epochs&#39;}
    layout_loss[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Loss %&#39;}
    layout_loss[&#39;autosize&#39;] = False
    layout_loss[&#39;height&#39;] = &#39;400&#39;
    layout_loss[&#39;width&#39;] = &#39;850&#39;
    layout_loss[&#39;margin&#39;] = dict(l=0, r=0, b=20, t=0),
    if (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 0) \
            and (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 0):
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=[1, 2, 3, 4, 5],
                y=[50, 50, 50, 50, 50],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;training&#39;] == 1) or \
            (es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;completed&#39;] == 1):
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)
    elif es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;load&#39;] == 1:
        body = es.get(index=es.get(index=&#39;model&#39;, id=1)[&#39;_source&#39;][&#39;name&#39;], id=1)[&#39;_source&#39;]
        data = [
            dict(
                name=&#39;Training&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
            dict(
                name=&#39;Validation&#39;,
                type=&#34;line&#34;,
                # mode=&#34;markers&#34;,
                x=body[&#39;training&#39;][&#39;epochs&#39;],
                y=body[&#39;training&#39;][&#39;val_loss&#39;],
                # opacity=0,
                hoverinfo=&#34;skip&#34;,
            ),
        ]
        figure = dict(data=data, layout=layout_loss)

    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_loss_graph_dash"><code class="name flex">
<span>def <span class="ident">update_loss_graph_dash</span></span>(<span>n_clicks, value, n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_loss_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;loss_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;),
               Input(&#39;input_text&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_loss_graph_dash(n_clicks, value, n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_loss_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_loss_graph(n_clicks, value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_mal_bar_graph"><code class="name flex">
<span>def <span class="ident">update_mal_bar_graph</span></span>(<span>value, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a bar graph of the top 20 malicious domains.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>Contains the interval after which the figure should be
refreshed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A bar graph that contains the top 20 malicious domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mal_bar_graph(value, interval):
    &#34;&#34;&#34;

    Function that returns a bar graph of the top 20 malicious domains.

    Args:
        value: Contains the value of the toggle switch
        interval: Contains the interval after which the figure should be
                  refreshed.

    Returns:
        A bar graph that contains the top 20 malicious domains.

    &#34;&#34;&#34;

    try:
        mal = es.get(index=&#39;mal&#39;, id=1)[&#39;_source&#39;]
    except:
        mal = {}
    if len(mal) &lt; 20:
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
    else:
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)][0:20]

    layout_bar = copy.deepcopy(layout)
    layout_bar[&#39;title&#39;] = &#34;Top Malicious Domains Queried&#34;
    layout_bar[&#39;xaxis&#39;] = {&#39;title&#39;: &#39;Rank (Hover over the bars for more info)&#39;,
                           &#39;tickvals&#39;: [(i + 1) for i in
                                        range(len(domain_names))]}
    layout_bar[&#39;yaxis&#39;] = {&#39;title&#39;: &#39;Number of Requests&#39;}
    layout_bar[&#39;margin&#39;] = dict(l=30, r=30, b=20, t=30),
    layout_bar[&#39;height&#39;] = &#39;400&#39;
    data = [
        dict(
            type=&#34;bar&#34;,
            hovertext=domain_names,
            x=[(i + 1) for i in range(len(domain_names))],
            y=[int(mal[i][&#39;count&#39;]) for i in domain_names],
        )]
    figure = dict(data=data, layout=layout_bar)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_mal_bar_graph_dash"><code class="name flex">
<span>def <span class="ident">update_mal_bar_graph_dash</span></span>(<span>value, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_mal_bar_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;mal_bar_graph&#39;, &#39;figure&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_mal_bar_graph_dash(value, interval):
    &#34;&#34;&#34;

    Function that just calls the update_mal_bar_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_mal_bar_graph(value, interval)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_mal_dns_table"><code class="name flex">
<span>def <span class="ident">update_mal_dns_table</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the data that contains the list of malicious domains.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nclicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the value of the toggle switch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Data that contains the list of malicious domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_mal_dns_table(nclicks, value):
    &#34;&#34;&#34;

    Function that returns the data that contains the list of malicious domains.

    Args:
        nclicks: Contains the number of clicks registered by the submit button.
        value: Contains the value of the toggle switch.

    Returns:
        Data that contains the list of malicious domains.

    &#34;&#34;&#34;

    try:
        mal = es.get(index=&#39;mal&#39;, id=1)[&#39;_source&#39;]
        domain_names = [key for (key, value) in
                        sorted(mal.items(), key=lambda x: x[1][&#39;count&#39;],
                               reverse=True)]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;acc&#39;: mal[i][&#39;status&#39;], &#39;count&#39;: mal[i][&#39;count&#39;]})
                for i, j in zip(domain_names, range(len(mal)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_mal_dns_table_dash"><code class="name flex">
<span>def <span class="ident">update_mal_dns_table_dash</span></span>(<span>nclicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_mal_dns_table function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;mal_dns_table&#39;, &#39;data&#39;),
              [Input(&#39;mal_toggle_switch&#39;, &#39;value&#39;),
               Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_mal_dns_table_dash(nclicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_mal_dns_table function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_mal_dns_table(nclicks, value)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_not_vetted_table"><code class="name flex">
<span>def <span class="ident">update_not_vetted_table</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the updated data of the list of non - vetted domains
after a specific interval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_intervals</code></strong></dt>
<dd>Contains the interval after which the data has to be updated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated data of the list of non - vetted domains.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_not_vetted_table(n_intervals):
    &#34;&#34;&#34;

    Function that returns the updated data of the list of non - vetted domains
    after a specific interval.

    Args:
        n_intervals: Contains the interval after which the data has to be updated.

    Returns:
        The updated data of the list of non - vetted domains.

    &#34;&#34;&#34;

    try:
        not_vetted = es.get(index=&#39;not_vetted&#39;, id=1)[&#39;_source&#39;]
        data = [dict({&#39;sl_no&#39;: j + 1, &#39;domain&#39;: i,
                      &#39;class&#39;: not_vetted[i][&#39;class&#39;],
                      &#39;acc&#39;: not_vetted[i][&#39;acc&#39;]})
                for i, j in zip(not_vetted.keys(), range(len(not_vetted)))]
    except:
        data = []
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_not_vetted_table_dash"><code class="name flex">
<span>def <span class="ident">update_not_vetted_table_dash</span></span>(<span>n_intervals)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_not_vetted_table function. This function
is decorated by the Dash Application decorator. Such an arrangement is used
as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;not_vetted_table&#39;, &#39;data&#39;),
              [Input(&#39;interval&#39;, &#39;n_intervals&#39;)])
def update_not_vetted_table_dash(n_intervals):
    &#34;&#34;&#34;

    Function that just calls the update_not_vetted_table function. This function
    is decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    data = update_not_vetted_table(n_intervals)
    return data</code></pre>
</details>
</dd>
<dt id="ui.update_pie_graph"><code class="name flex">
<span>def <span class="ident">update_pie_graph</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns a pie graph whether the domain name entered is
malicious or benign.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Contains the probability whether the domain name entered is
malicious or benign.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A pie graph that displays the probability whether the domain name
entered is malicious or benign.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_pie_graph(n_clicks, value):
    &#34;&#34;&#34;

    Function that returns a pie graph whether the domain name entered is
    malicious or benign.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        value: Contains the probability whether the domain name entered is
               malicious or benign.

    Returns:
        A pie graph that displays the probability whether the domain name
        entered is malicious or benign.

    &#34;&#34;&#34;

    layout_pie = copy.deepcopy(layout)
    layout_pie[&#34;title&#34;] = &#39;Prediction&#39;
    layout_pie[&#34;font&#34;] = dict(color=&#34;#777777&#34;)
    layout_pie[&#34;legend&#34;] = dict(font=dict(color=&#34;#777777&#34;, size=&#34;10&#34;),
                                orientation=&#34;v&#34;, bgcolor=&#34;rgba(0,0,0,0)&#34;)
    layout_pie[&#34;width&#34;] = &#39;350&#39;
    layout_pie[&#34;height&#34;] = &#39;150&#39;
    if value is None or value is &#39;&#39;:
        data = [
            dict(
                type=&#34;pie&#34;,
                labels=[&#34;Benign&#34;, &#34;Malicious&#34;],
                values=[0.5, 0.5],
                textinfo=&#34;label+percent+name&#34;,
                hole=0.5,
                marker=dict(colors=[&#34;#3498db&#34;, &#34;#f5b041 &#34;]),
                domain={&#34;x&#34;: [0.2, 0.9], &#34;y&#34;: [0.2, 0.9]},
            )]
        figure = dict(data=data, layout=layout_pie)
        return figure
    else:
        try:
            pred = float(es.get(index=value, id=1)[&#39;_source&#39;][&#39;status&#39;])
        except:
            pred = 0.5
        data = [
            dict(
                type=&#34;pie&#34;,
                labels=[&#34;Benign&#34;, &#34;Malicious&#34;],
                values=[1 - pred, pred],
                textinfo=&#34;label+percent+name&#34;,
                hole=0.5,
                marker=dict(colors=[&#34;#3498db&#34;, &#34;#f5b041 &#34;]),
                domain={&#34;x&#34;: [0.2, 0.9], &#34;y&#34;: [0.2, 0.9]},
            )]
        figure = dict(data=data, layout=layout_pie)
        return figure</code></pre>
</details>
</dd>
<dt id="ui.update_pie_graph_dash"><code class="name flex">
<span>def <span class="ident">update_pie_graph_dash</span></span>(<span>n_clicks, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_pie_graph function. This function is
decorated by the Dash Application decorator. Such an arrangement is used as
unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback(Output(&#39;pie_graph&#39;, &#39;figure&#39;),
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_pie_graph_dash(n_clicks, value):
    &#34;&#34;&#34;

    Function that just calls the update_pie_graph function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used as
    unit testing decorated functions is complex.

    &#34;&#34;&#34;

    figure = update_pie_graph(n_clicks, value)
    return figure</code></pre>
</details>
</dd>
<dt id="ui.update_whois_info"><code class="name flex">
<span>def <span class="ident">update_whois_info</span></span>(<span>n_clicks, domain_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that returns the the information of the domain name queried from
the WhoIS Database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_clicks</code></strong></dt>
<dd>Contains the number of clicks registered by the submit button.</dd>
<dt><strong><code>domain_name</code></strong></dt>
<dd>Contains the domain name queried.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Information from the WhoIS Database regarding the domain name queried.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_whois_info(n_clicks, domain_name):
    &#34;&#34;&#34;

    Function that returns the the information of the domain name queried from
    the WhoIS Database.

    Args:
        n_clicks: Contains the number of clicks registered by the submit button.
        domain_name: Contains the domain name queried.

    Returns:
        Information from the WhoIS Database regarding the domain name queried.

    &#34;&#34;&#34;

    whois_ip = &#39;&#39;
    whois_hostnames = &#39;&#39;
    whois_city = &#39;&#39;
    whois_state = &#39;&#39;
    whois_country = &#39;&#39;
    whois_date_registered = &#39;&#39;
    whois_registrar = &#39;&#39;

    if domain_name is None or domain_name == &#39;&#39;:
        domain_name = &#39;&#39;

    else:

        try:
            api_key = &#39;at_r4GfBsGDWwZpuaga703KB9HZBmG6S&#39;
            url = &#39;https://www.whoisxmlapi.com/whoisserver/WhoisService?&#39; \
                  + &#39;domainName=&#39; + domain_name + &#39;&amp;apiKey=&#39; + api_key + \
                  &#34;&amp;outputFormat=JSON&#34; + &#34;&amp;ip=1&#34;

            data = json.loads(urlopen(url).read().decode(&#39;utf8&#39;))

            if &#39;ErrorMessage&#39; in data.keys():

                domain_name = data[&#39;msg&#39;]

            else:

                try:
                    ips = data[&#39;WhoisRecord&#39;][&#39;ips&#39;]
                    for i in ips:
                        whois_ip = whois_ip + i + &#39; | &#39;
                except:
                    whois_ip = &#39;-&#39;

                try:
                    hostnames = data[&#39;WhoisRecord&#39;][&#39;nameServers&#39;][&#39;hostNames&#39;]
                    for i in hostnames:
                        whois_hostnames = whois_hostnames + i + &#39; | &#39;
                except:
                    whois_hostnames = &#39;-&#39;

                try:
                    whois_city = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;city&#39;]
                except:
                    whois_city = &#39;-&#39;

                try:
                    whois_state = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;state&#39;]
                except:
                    whois_state = &#39;-&#39;

                try:
                    whois_country = data[&#39;WhoisRecord&#39;][&#39;registrant&#39;][&#39;country&#39;]
                except:
                    whois_country = &#39;-&#39;

                try:
                    whois_date_registered = \
                        data[&#39;WhoisRecord&#39;][&#39;registryData&#39;][&#39;createdDateNormalized&#39;]
                except:
                    whois_date_registered = &#39;-&#39;

                try:
                    whois_registrar = data[&#39;WhoisRecord&#39;][&#39;registrarName&#39;]
                except:
                    whois_registrar = &#39;-&#39;

        except:
            domain_name = domain_name + &#39; (WhoIS Unresponsive)&#39;

    return domain_name, whois_ip, whois_hostnames, whois_city, \
           whois_state, whois_country, whois_date_registered, whois_registrar</code></pre>
</details>
</dd>
<dt id="ui.update_whois_info_dash"><code class="name flex">
<span>def <span class="ident">update_whois_info_dash</span></span>(<span>n_clicks, domain_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that just calls the update_whois_info function. This function is
decorated by the Dash Application decorator. Such an arrangement is used
as unit testing decorated functions is complex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.callback([Output(&#39;whois_domain&#39;, &#39;children&#39;),
               Output(&#39;whois_ips&#39;, &#39;children&#39;),
               Output(&#39;whois_hostnames&#39;, &#39;children&#39;),
               Output(&#39;whois_city&#39;, &#39;children&#39;),
               Output(&#39;whois_state&#39;, &#39;children&#39;),
               Output(&#39;whois_country&#39;, &#39;children&#39;),
               Output(&#39;whois_date&#39;, &#39;children&#39;),
               Output(&#39;whois_registrar&#39;, &#39;children&#39;)],
              [Input(&#39;submit_input&#39;, &#39;n_clicks&#39;)],
              [State(&#39;input_text&#39;, &#39;value&#39;)])
def update_whois_info_dash(n_clicks, domain_name):
    &#34;&#34;&#34;

    Function that just calls the update_whois_info function. This function is
    decorated by the Dash Application decorator. Such an arrangement is used
    as unit testing decorated functions is complex.

    &#34;&#34;&#34;

    whois_domain, whois_ips, whois_hostnames, whois_city, whois_state, \
    whois_country, whois_date, whois_registrar = \
        update_whois_info(n_clicks, domain_name)

    return whois_domain, whois_ips, whois_hostnames, whois_city, whois_state, \
           whois_country, whois_date, whois_registrar</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ui.date_message" href="#ui.date_message">date_message</a></code></li>
<li><code><a title="ui.date_message_dash" href="#ui.date_message_dash">date_message_dash</a></code></li>
<li><code><a title="ui.display_benign_graph" href="#ui.display_benign_graph">display_benign_graph</a></code></li>
<li><code><a title="ui.display_benign_graph_dash" href="#ui.display_benign_graph_dash">display_benign_graph_dash</a></code></li>
<li><code><a title="ui.display_benign_list" href="#ui.display_benign_list">display_benign_list</a></code></li>
<li><code><a title="ui.display_benign_list_dash" href="#ui.display_benign_list_dash">display_benign_list_dash</a></code></li>
<li><code><a title="ui.display_hour_range" href="#ui.display_hour_range">display_hour_range</a></code></li>
<li><code><a title="ui.display_hour_range_dash" href="#ui.display_hour_range_dash">display_hour_range_dash</a></code></li>
<li><code><a title="ui.display_mal_graph" href="#ui.display_mal_graph">display_mal_graph</a></code></li>
<li><code><a title="ui.display_mal_graph_dash" href="#ui.display_mal_graph_dash">display_mal_graph_dash</a></code></li>
<li><code><a title="ui.display_mal_list" href="#ui.display_mal_list">display_mal_list</a></code></li>
<li><code><a title="ui.display_mal_list_dash" href="#ui.display_mal_list_dash">display_mal_list_dash</a></code></li>
<li><code><a title="ui.hour_range_message" href="#ui.hour_range_message">hour_range_message</a></code></li>
<li><code><a title="ui.hour_range_message_dash" href="#ui.hour_range_message_dash">hour_range_message_dash</a></code></li>
<li><code><a title="ui.input_message" href="#ui.input_message">input_message</a></code></li>
<li><code><a title="ui.input_message_dash" href="#ui.input_message_dash">input_message_dash</a></code></li>
<li><code><a title="ui.radio_button_message" href="#ui.radio_button_message">radio_button_message</a></code></li>
<li><code><a title="ui.radio_button_message_dash" href="#ui.radio_button_message_dash">radio_button_message_dash</a></code></li>
<li><code><a title="ui.update_acc_graph" href="#ui.update_acc_graph">update_acc_graph</a></code></li>
<li><code><a title="ui.update_acc_graph_dash" href="#ui.update_acc_graph_dash">update_acc_graph_dash</a></code></li>
<li><code><a title="ui.update_and_input_vet_message_vet_tables" href="#ui.update_and_input_vet_message_vet_tables">update_and_input_vet_message_vet_tables</a></code></li>
<li><code><a title="ui.update_and_input_vet_message_vet_tables_dash" href="#ui.update_and_input_vet_message_vet_tables_dash">update_and_input_vet_message_vet_tables_dash</a></code></li>
<li><code><a title="ui.update_benign_bar_graph" href="#ui.update_benign_bar_graph">update_benign_bar_graph</a></code></li>
<li><code><a title="ui.update_benign_bar_graph_dash" href="#ui.update_benign_bar_graph_dash">update_benign_bar_graph_dash</a></code></li>
<li><code><a title="ui.update_benign_dns_table" href="#ui.update_benign_dns_table">update_benign_dns_table</a></code></li>
<li><code><a title="ui.update_benign_dns_table_dash" href="#ui.update_benign_dns_table_dash">update_benign_dns_table_dash</a></code></li>
<li><code><a title="ui.update_benign_vet_table" href="#ui.update_benign_vet_table">update_benign_vet_table</a></code></li>
<li><code><a title="ui.update_benign_vet_table_dash" href="#ui.update_benign_vet_table_dash">update_benign_vet_table_dash</a></code></li>
<li><code><a title="ui.update_blacklist_vet_table" href="#ui.update_blacklist_vet_table">update_blacklist_vet_table</a></code></li>
<li><code><a title="ui.update_blacklist_vet_table_dash" href="#ui.update_blacklist_vet_table_dash">update_blacklist_vet_table_dash</a></code></li>
<li><code><a title="ui.update_confusion_matrix_test" href="#ui.update_confusion_matrix_test">update_confusion_matrix_test</a></code></li>
<li><code><a title="ui.update_confusion_matrix_test_dash" href="#ui.update_confusion_matrix_test_dash">update_confusion_matrix_test_dash</a></code></li>
<li><code><a title="ui.update_confusion_matrix_training" href="#ui.update_confusion_matrix_training">update_confusion_matrix_training</a></code></li>
<li><code><a title="ui.update_confusion_matrix_training_dash" href="#ui.update_confusion_matrix_training_dash">update_confusion_matrix_training_dash</a></code></li>
<li><code><a title="ui.update_confusion_matrix_validation" href="#ui.update_confusion_matrix_validation">update_confusion_matrix_validation</a></code></li>
<li><code><a title="ui.update_confusion_matrix_validation_dash" href="#ui.update_confusion_matrix_validation_dash">update_confusion_matrix_validation_dash</a></code></li>
<li><code><a title="ui.update_confusion_metrics_test" href="#ui.update_confusion_metrics_test">update_confusion_metrics_test</a></code></li>
<li><code><a title="ui.update_confusion_metrics_test_dash" href="#ui.update_confusion_metrics_test_dash">update_confusion_metrics_test_dash</a></code></li>
<li><code><a title="ui.update_confusion_metrics_training" href="#ui.update_confusion_metrics_training">update_confusion_metrics_training</a></code></li>
<li><code><a title="ui.update_confusion_metrics_training_dash" href="#ui.update_confusion_metrics_training_dash">update_confusion_metrics_training_dash</a></code></li>
<li><code><a title="ui.update_confusion_metrics_validation" href="#ui.update_confusion_metrics_validation">update_confusion_metrics_validation</a></code></li>
<li><code><a title="ui.update_confusion_metrics_validation_dash" href="#ui.update_confusion_metrics_validation_dash">update_confusion_metrics_validation_dash</a></code></li>
<li><code><a title="ui.update_display_training_options" href="#ui.update_display_training_options">update_display_training_options</a></code></li>
<li><code><a title="ui.update_display_training_options_dash" href="#ui.update_display_training_options_dash">update_display_training_options_dash</a></code></li>
<li><code><a title="ui.update_es_parameters_and_messages" href="#ui.update_es_parameters_and_messages">update_es_parameters_and_messages</a></code></li>
<li><code><a title="ui.update_es_parameters_and_messages_dash" href="#ui.update_es_parameters_and_messages_dash">update_es_parameters_and_messages_dash</a></code></li>
<li><code><a title="ui.update_honeypot_vet_table" href="#ui.update_honeypot_vet_table">update_honeypot_vet_table</a></code></li>
<li><code><a title="ui.update_honeypot_vet_table_dash" href="#ui.update_honeypot_vet_table_dash">update_honeypot_vet_table_dash</a></code></li>
<li><code><a title="ui.update_ip_table" href="#ui.update_ip_table">update_ip_table</a></code></li>
<li><code><a title="ui.update_ip_table_dash" href="#ui.update_ip_table_dash">update_ip_table_dash</a></code></li>
<li><code><a title="ui.update_line_graph" href="#ui.update_line_graph">update_line_graph</a></code></li>
<li><code><a title="ui.update_line_graph_dash" href="#ui.update_line_graph_dash">update_line_graph_dash</a></code></li>
<li><code><a title="ui.update_loss_accuracy_display" href="#ui.update_loss_accuracy_display">update_loss_accuracy_display</a></code></li>
<li><code><a title="ui.update_loss_accuracy_display_dash" href="#ui.update_loss_accuracy_display_dash">update_loss_accuracy_display_dash</a></code></li>
<li><code><a title="ui.update_loss_graph" href="#ui.update_loss_graph">update_loss_graph</a></code></li>
<li><code><a title="ui.update_loss_graph_dash" href="#ui.update_loss_graph_dash">update_loss_graph_dash</a></code></li>
<li><code><a title="ui.update_mal_bar_graph" href="#ui.update_mal_bar_graph">update_mal_bar_graph</a></code></li>
<li><code><a title="ui.update_mal_bar_graph_dash" href="#ui.update_mal_bar_graph_dash">update_mal_bar_graph_dash</a></code></li>
<li><code><a title="ui.update_mal_dns_table" href="#ui.update_mal_dns_table">update_mal_dns_table</a></code></li>
<li><code><a title="ui.update_mal_dns_table_dash" href="#ui.update_mal_dns_table_dash">update_mal_dns_table_dash</a></code></li>
<li><code><a title="ui.update_not_vetted_table" href="#ui.update_not_vetted_table">update_not_vetted_table</a></code></li>
<li><code><a title="ui.update_not_vetted_table_dash" href="#ui.update_not_vetted_table_dash">update_not_vetted_table_dash</a></code></li>
<li><code><a title="ui.update_pie_graph" href="#ui.update_pie_graph">update_pie_graph</a></code></li>
<li><code><a title="ui.update_pie_graph_dash" href="#ui.update_pie_graph_dash">update_pie_graph_dash</a></code></li>
<li><code><a title="ui.update_whois_info" href="#ui.update_whois_info">update_whois_info</a></code></li>
<li><code><a title="ui.update_whois_info_dash" href="#ui.update_whois_info_dash">update_whois_info_dash</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>